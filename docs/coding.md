<!-- Coding -->
# 编码

# 目录

- [清单](#清单)
- [Golang](#golang)
- [消息队列Kafka](#消息队列kafka)
- [Linux](#linux)
- [网络安全](#网络安全)
- [Golang](#golang)
- [Other](#other)
- [格式化](#格式化)
- [数据结构及算法](#数据结构及算法)

# 清单

## Docker

## Kubernates

## 负载均衡

## Restful API设计

## MVC框架

## 常用设计模式

> 单库单应用模式：最简单的，可能大家都见过
> 内容分发模式：目前用的比较多
> 查询分离模式：对于大并发的查询、业务
> 微服务模式：适用于复杂的业务模式的拆解
> 多级缓存模式：可以把缓存玩的很好
> 分库分表模式：解决单机数据库瓶颈
> 弹性伸缩模式：解决波峰波谷业务流量不均匀的方法之一
> 多机房模式：解决高可用、高性能的一种方法

## 池子的设计：内存池、进程池、线程池

直接从池中取得所需资源比动态分配资源的速度要快得多，因为分配系统资源的系统调用都是很耗时的。当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用来释放资源。从最终效果来看，池相当于服务器管理系统资源的应用设施，它避免了服务器对内核的频繁访问。

## 新名词和技术

DPI：一种基于应用层的流量检测和控制技术，称为“深度包检测”，还可以通过设置不同的权重，来分离各种数据包，从而更高效的应用有限的网络宽带资源，具有管理网络性能的用处。
架构和部署

## 分布式系统

建立在网络之上的软件系统：<https://baike.baidu.com/item/分布式系统/4905336>
分布式：<https://zhuanlan.zhihu.com/p/140272240>

## 分布式计算：hadoop、HBase

现在普遍认为整个Apache Hadoop“平台”包括Hadoop内核、MapReduce、Hadoop分布式文件系统（HDFS）以及一些相关项目，有Apache Hive和Apache HBase等等；
主要子项目
Apache HBase：分布式NoSQL列数据库，类似谷歌公司BigTable。
Apache Hive：构建于hadoop之上的数据仓库，通过一种类SQL语言HiveQL为用户提供数据的归纳、查询和分析等功能。Hive最初由Facebook贡献。
Apache Mahout：机器学习算法软件包。
Apache Sqoop：结构化数据（如关系数据库）与Apache Hadoop之间的数据转换工具。
Apache ZooKeeper：分布式锁设施，提供类似Google Chubby的功能，由Facebook贡献。
Apache Avro：新的数据序列化格式与传输工具，将逐步取代Hadoop原有的IPC机制。
维基百科：<https://zh.wikipedia.org/zh-cn/Apache_Hadoop>

## 消息队列

解决的问题：解耦、异步、削峰
架构中引入MQ后存在的问题：
降低系统可用性。如果MQ挂掉，导致整个系统崩溃；
系统复杂性变高。可能发重复消息，导致插入重复数据；消息丢了；消息顺序乱了；系统B,C,D挂了，导致MQ消息积累，磁盘满了；
一致性问题。本来应该A,B,C,D都执行成功了再返回，结果A,B,C执行成功D失败。
建议：中小型公司RabbitMQ，大公司：RocketMQ，大数据实时计算：Kafka。
解决方案：
事务机制：（一般不采用，同步的，生产者发送消息会同步阻塞卡住等待你是成功还是失败。会导致生产者发送消息的吞吐量降下来）；
持久化到磁盘；>
链接：<https://zhuanlan.zhihu.com/p/356235333>
Go语言系列之RabbitMQ消息队列：<https://blog.51cto.com/u_13919520/3153035>
消息队列对比详解：<https://baijiahao.baidu.com/s?id=1708572554459077699&wfr=spider&for=pc>

## 如何实现一个RPC框架

链接：<https://xiaozhuanlan.com/topic/8472610953>

## 分布式系统、微服务

微服务是架构设计方式，分布式是系统部署方式，两者概念不同
ESB（企业服务总线）、微服务API网关
简单来说ESB就是一根管道，用来连接各个服务节点。为了集成不同系统，不同协议的服务，ESB做了消息的转化解释和路由工作，让不同的服务互联互通；
API网关是一个服务器，是系统的唯一入口。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。
链接：<https://www.cnblogs.com/xuwc/p/13989081.html>
SOA架构（Service Oriented Architecture）
面向服务的架构。它是一种设计方法，其中包含多个服务，服务之间通过相互依赖最终提供一系列的功能。
IOT（Internet of Things）物联网平台/应用
安全性是物联网首要考虑的问题；
网络通信协议和Web：
Web（WorldWideWeb）全球广域网，是一种基于超文本HTML和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。建立在Internet上的一种网络服务

## http三个版本区别

1.0短链接（100张图，100次tcp握手和挥手）
1.1长连接（100张图，1次tcp握手挥手）
2.0长连接+多路复用模型（五大模型之一）

## 网路名词

- DNS：域名服务器（DomainNameServer）提供域名解析的服务，实现域名到ip地址之间的转化，网络之间是通过ip连接的，域名只是为了方便记忆；
- 路由：连接多个网络或网段的网络设备，它能将不同网络或网段之间的数据信息进行“翻译”，以使它们能够相互“读”懂对方的数据，从而构成一个更大的网络。
- Web响应状态码：是服务端对客户端请求的一种状态响应，不同的状态码代表着服务端对请求的不同响应结果。
- LAN：局部区域网，局域网，本地网（全写为localareanetwork）;
- DHCP：（动态主机配置协议）是一个局域网的网络协议。
- VPN：（虚拟专用网络）通过一个公用互联网络建立的一个临时、安全、稳定隧道，使用这条隧道可以对数据进行几倍加密，主要使用在企业办公当中。
- ICMP：（因特网控制报文协议）TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。这些控制消息不传输用户数据，但是对于用户数据的传递起着重要的作用。ICMP报文有两种：差错报告报文和询问报文；
- RPC：（远程过程调用协议）是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式、多程序在内的应用程序更加容易。
- ARP（Address Resolution Protocol)（地址解析协议）提供了网络层地址（IP地址）到物理地址（mac地址）之间的动态映射。网络层以上的协议用IP地址来标识网络接口，但以太数据帧传输时，以物理地址来标识网络接口，因此我们需要进行IP地址与物理地址之间的转化。
- API：（应用编程接口）是一些预先定义的函数，或指软件系统不同组成部分，衔接的约定。目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节。
- ORM：（对象关系映射）用于实现面向对象编程语言里不同类型系统的数据之间的转换的一种程序技术。ORM提供了对数据库的映射，不用sql直接编码，能够像操作对象一样从数据库获取数据。提高了开发效率。ORM可以自动对实体对象与数据库中的表进行字段与属性的映射，所以我们实际可能已经不需要一个专用的、庞大的数据访问层。

## websocket

是HTML5开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。
Socket是TCP层的封装，浏览器和服务器只需要做一个握手的动作就可以实现数据的相互传送；
Header很小，信息传输效率高；服务器可以主动推送数据到浏览器；
socket长连接：指的是客户端和服务端之间保持一个socket连接长时间不断开，保持连接的情况下可以节省系统资源；

## 网络延时、完整性约束

时延：是指一个报文或分组从一个网络（或一条链路）的一端传送到另一端所需的时间；
数据完整性约束：为了防止不符合规范的数据进入数据库，在用户对数据进行插入、修改、删除等操作时，DBMS自动按照一定的约束条件对数据进行监测，使不符合规范的数据不能进入数据库，以确保数据库中存储的数据正确、有效、相容；

## 脏数据

是指源系统中的数据不在给定的范围内或对于实际业务毫无意义，或是数据格式非法，以及在源系统中存在不规范的编码和含糊的业务逻辑。
在数据库技术中,脏数据产生于临时更新（脏读）。例如：事务A更新了某个数据项X，由于某种原因事务A回滚。但是在回滚之前，另一个事务B读取了数据项X的值，A回滚了事务，数据项恢复了原值。事务B读取的就是数据项X的就是一个“临时”的值，就是脏数据。
《图解TCP/IP》读书笔记：<https://www.cnblogs.com/edisonchou/p/5987827.html>
数据在TCP层称为流（Stream），数据分组称为分段（Segment）。作为比较，数据在IP层称为Datagram，数据分组称为分片（Fragment）。UDP中分组称为Message。
粘包现象值存在于TCP协议，UDP协议不存在粘包的情况

## 粘包原因

发送端：连续发送多个小的数据包（就是指字节数小于报文段-MSS的大小），由于Nagle优化算法导致的几个小包合并为一个包。
接收端：一次从自己的缓冲区中能够读取的字节数少于对端发送的一个数据包的字节数，导致本段在读取的时候数据不能一次读取完毕
拆包解决：提前告知数据大小，将数据长度合并到报文中，由程序标识数据流的结束。
广域网（WAN,公网,外网），就是我们通常所说的Internet，它是一个遍及全世界的网络。局域网（LAN,私网,内网），相对于广域网（WAN）而言，主要是指在小范围内的计算机互联网络。这个“小范围”可以是一个家庭，一所学校，一家公司，或者是一个政府部门。BT中常常提到的公网、外网，即广域网（WAN）；BT中常常提到私网、内网，即局域网（LAN）。广域网上的每一台电脑（或其他网络设备）都有一个或多个广域网IP地址（或者说公网、外网IP地址），广域网IP地址一般要到ISP处交费之后才能申请到，广域网IP地址不能重复；局域网（LAN）上的每一台电脑（或其他网络设备）都有一个或多个局域网IP地址（或者说私网、内网IP地址），局域网IP地址是局域网内部分配的，不同局域网的IP地址可以重复，不会相互影响。
路由器和交换机？
交换机工作在OSI的第二层（数据链路层），所以它的工作原理比较简单，而路由器工作在OSI的第三层（网络层），可以得到更多的协议信息，路由器可以做出更加智能的转发决策。
交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用不同网络的ID号（即IP地址）来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络，有时这些第三层的地址也称为协议地址或者网络地址。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。
传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。
路由器提供了防火墙的服务。路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。
CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。
Haproxy是一个使用C语言编写的自由及开放源代码软件，其提供高可用性、负载均衡，以及基于TCP和HTTP的应用程序代理。HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。HAProxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中，同时可以保护你的web服务器不被暴露到网络上。HAProxy实现了一种事件驱动,单一进程模型，此模型支持非常大的并发连接数。多进程或多线程模型受内存限制、系统调度器限制以及无处不在的锁限制，很少能处理数千并发连接。事件驱动模型因为在有更好的资源和时间管理的用户空间(User-Space)实现所有这些任务，所以没有这些问题。此模型的弊端是，在多核系统上，这些程序通常扩展性较差。这就是为什么他们必须进行优化以使每个CPU时间片(Cycle)做更多的工作。
keepalived是一个类似于Layer2,4,7交换机制的软件。是Linux集群管理中保证集群高可用的一个服务软件，其功能是用来防止单点故障。keepalived的工作原理：keepalived是基于VRRP协议实现的保证集群高可用的一个服务软件，主要功能是实现真机的故障隔离和负载均衡器间的失败切换，防止单点故障。在了解keepalived原理之前先了解一下VRRP协议。
VRRP协议：Virtual Route Redundancy Protocol虚拟路由冗余协议。是一种容错协议，保证当主机的下一跳路由出现故障时，由另一台路由器来代替出现故障的路由器进行工作，从而保持网络通信的连续性和可靠性。
单点登录：SSO（Single Sign On），是指在一个多系统共存的环境下，用户在一处登录后，就不用在其它系统中登录，也就是用户的一次登录就能得到其它所有系统的信任；对于大型系统来说使用单点登录可以减少用户很多的麻烦，多台主机负载均衡的话就涉及到session共享的问题，实现单点登录要解决如何产生和存储信任，再就是其它系统如何验证这个信任的有效性，因此要点有两个：存储信任，-验证信任：①以Cookie作为凭借媒介，②通过JSONP实现，③通过页面重定向的方式，④使用独立登录系统；
网络掩码的作用：将某个IP地址划分成网络地址和主机地址两部分

HTTP客户端状态码含义：
400 bad request，请求报文存在语法错误
401 unauthorized，表示发送的请求需要有通过HTTP认证的认证信息
403 forbidden，表示对请求资源的访问被服务器拒绝
404 not found，表示在服务器上没有找到请求的资源
TCP/IP协议
握手详解：<https://blog.csdn.net/Jalon2015/article/details/115219026>
HTTP：keep-alive
client发出的HTTP请求头需要增加Connection:keep-alive字段
Web-Server端要能识别Connection:keep-alive字段，并且在http的response里指定Connection:keep-alive字段，告诉client，我能提供keep-alive服务，并且"应允"client我暂时不会关闭socket连接
http能不能一次连接多次请求，不等后端返回
http本质上市是用socket连接，因此发送请求，接写入tcp缓冲，是可以多次进行的，这也是http是无状态的原因
Time Wait的做用
防止上一次连接中的分段延迟到达后影响新连接
TIME_WAIT状态持续2MSL后，原连接的数据包都已经在网络上消失，不会再干扰新连接。
链接：<https://blog.csdn.net/iCode_girl/article/details/108595066>
Socket：
TCP是面向连接的套接字，而UDP是面向无连接的套接字；
TCP编程的客户端和服务端都是通过Socket来完成的。
tcp与udp区别，udp优点，适用场景
tcp传输的是数据流，而udp是数据包，tcp会进过三次握手，udp不需要
TCP协议
Transmission Control Protocol（传输控制协议）是一种面向连接（连接导向）的、可靠的、基于IP的传输协议。
通过排序（保证数据的读取是按照正确的格式进行）和重传（保证数据能准确传输到目的地）来确保数据传输的可靠性（即数据的准确传输以及完整性）；

## 集群（技术）

集群（cluster）技术是一种较新的技术，通过集群技术，可以在付出较低成本的情况下获得在性能、可靠性、灵活性方面的相对较高的收益，其任务调度则是集群系统中的核心技术。
集群是一组相互独立的、通过高速网络互联的计算机，它们构成了一个组，并以单一系统的模式加以管理。一个客户与集群相互作用时，集群像是一个独立的服务器。集群配置是用于提高可用性和可缩放性。
百度百科：<https://baike.baidu.com/item/集群技术/9774443>

工具
git文件版本，使用顺序，merge跟rebase
rebase和merge的区别：<https://blog.csdn.net/weixin_41231928/article/details/107040880>
Git回滚代码到某个commit
2个回退命令即可完成回退到提交的commited节点
Git log：获取历史提交信息；
Git reset--hard commited_id(提交记录的唯一标识id)

## 常见编程语言及应用环境

1.C：操作系统、嵌入式、驱动开发；
2.C++：图形图像、科研、通信、桌面软件、游戏、游戏服务器；
3.C#：Windows桌面软件、.NET Web、服务器
4.Java： Java SE：跨平台的桌面应用，Android；Java EE：企业级应用，web开发、服务器后端；Java ME：手机应用、流行于非智能机时代；Java Android：用于安卓开发应用
5.GO：高性能服务器应用，比较年轻
6.Erlang：高并发服务器应用，多用于游戏
7.Python：Web、科学计算、运维
8.Ruby：web
9.HTML/CSS：标记语言，主要是给前端工程师构建页面使用
10.Python应用领域主要有：自动化运维、人工智能领域、网路爬虫、科学计算
汇编语言：汇编语言（Assembly Language）是任何一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。

## 网络编程

## 第三章 数据库-MySQL

1、事务、事务隔离级别
2、索引：主键索引和唯一索引
3、Mysql B+树
4、两种引擎：MyISAM、InnoDB
5、数据库设计三范式
6、SQL优化策略：<https://www.51cto.com/article/623584.html>
7、SQL注入问题
8、多版本并发控制
9、聚簇索引、非聚簇索引

## 数据库设计及优化

优秀的数据库设计，可以减少数据冗余、避免数据维护异常、节约空间、高效访问。
步骤：
需求分析：分析数据属性和特点
逻辑设计：使用ER图【实体-联系图(Entity Relationship Diagram)】对数据库进行逻辑建模
物理设计：根据数据库自身的特点 将逻辑设计转化为物理设计
维护优化：新的需求进行建表、索引优化、大表拆分
详细：<https://www.jianshu.com/p/23a36a453b56>

## 数据库查询整体优化思路

为什么优化：随着程序的使用和业务的拓展，导致数据量越来越大，数据库处理压力增大、吞吐量出现瓶颈；
优化的思路：
1. 表字段在设计阶段，通过需求分析及逻辑设计阶段，使用ER图【实体-联系图(Entity Relationship Diagram)】对数据库进行逻辑建模，并根据数据库自身的特点，将逻辑设计转化为物理设计，采用更优的表、字段的存储方案；
2. 采用数据库自身提供的优化方案，如创建更适合业务需求的索引；
3. 查询缓存、热点、稳定数据缓存；
4. 横向扩展、主从复制、读写分离等方式，实现高性能和高可用；
5. 查询逻辑及语句优化，根据查询日志，定位查询效率较低的SQL，针对性做优化；
EXPLAIN命令是查看优化器如何决定执行查询的主要方法，我们可一利用这个来优化我们的sql和添加索引。
链接：<https://blog.csdn.net/qq_36622496/article/details/90638765>

## 缓存-Redis

1.Redis基本概念；
2.Redis基本数据结构与常用指令；
3.Redis；
4.Redis八种淘汰策略与三种删除策略；
5.Redis三种持久化机制；
6.Redis事务机制；
7.Redis内存模型及内存划分；
8.Redis虚拟内存；
9.Redis客户端通信RESP协议；
10.Redis高可用机制：主从复制、哨兵、代理式/分片式集群；
> Redis面试宝典：<https://baijiahao.baidu.com/s>
> 数据结构和命令：<https://blog.csdn.net/m0_64830623/article/details/123145942>
> Redis五大数据类型及使用场景：<https://baijiahao.baidu.com/s?id=1682379171066196544&wfr=spider&for=pc>
> Redis核心底层协议-RESP：<https://baijiahao.baidu.com/s?id=1669496265525774478&wfr=spider&for=pc>
> 网址：<https://xiaolincoding.com/redis/>

## 缓存

1.提高系统的性能，尽量减少IO的操作，特别是磁盘IO的操作；
2.使用缓存技术来提高系统的性能，并且降低数据库的负载。缓存就是通过在本地磁盘内保存的资源副本，减少对源服务器的访问，节省通信流量和通信时间，提高系响应速度和用户体验；

## 缓存与DB数据一致性问题

1、读写分离：读请求只访问缓存，写请求只修改数据库和缓存。写请求修改数据库和缓存是事务性动作，如果更新数据库成功，更新缓存失败，则回滚数据库，保证缓存与数据库数据的强一致。这样实现了读写分离，不仅提高了读的响应速度，由写请求负责缓存与数据库一致，只有写请求成功才会影响到缓存的内容，时效性大大增强。
2、缓存队列：沿用场景一的解决方案，为解决其缺陷，添加队列，凡是遇到写请求，则将写请求放入队列中，由队列对写请求统一管理，写请求处理成功，则从队列中删除。当有一个读请求过来时，到队列查询，是否有对应的写请求，如果有则放入队列中，等待写请求执行完之后再执行读请求。为防止某个请求阻塞情况，为其设置超时机制或者过期机制。
3、读写分离缓存队列：访问量大，处理器来不及处理，队列内的请求数量越来越高，则会影响查询效率。解决：分布式数据库集群，再加上消息队列 （kafka等等）

## 第五章 网络基础

1、常用端口号：Redis（6379）、MySQL（3306）、PostgreSQL（5432）、HTTP（80）、HTTPS（443）
2、REST，RESTFUL及特点
3、常用状态码
4、TCP三次握手与四次挥手
5、远程调用：RPC
6、HTTP 2.0特性
7、Websocket特点
8、HTTP和HTTPS
9、TCP、UDP
10、网际控制报文协议ICMP，
11、OSI七层、TCP/IP四层
12、IP地址分类和基本特点
13、域名解析(DNS解析)
14、数据链路层的作用
> 网络基础知识学习网址：<https://xiaolincoding.com/network/>

## 网络硬件设备

- 中继器：中继器从一个网络电缆里接收信号， 放大它们，将其送入下一个电缆。
- 集线器：相当于多接口中继器，可将各节点连接成一个局域网，但任何时刻都只能有一个节点通过公共信道发送数据。逻辑上仍然是一个总线网，使用CSMA/CD协议。不能隔离碰撞域。不能连接不同技术和速率的网络。
- 网桥：相比较而言，网桥对从关卡上传下来的信息更敏锐一些。网桥是一种对帧进行转发的技术，根据MAC分区块，可隔离碰撞。网桥将网络的多个网段在数据链路层连接起来。
- 交换机：用于电光信号转发的网络设备，它可以为接入交换机的任意两个网络节点提供独享的电信号通路。工作在数据链路层相当于多端口的网桥，允许端口之间建立多个并发连接，实现多个节点之间并发传输，每个端口所占带宽不会因为端口数量增加而减少
- 路由器：使用物理层或数据链路层的中继系统时只是把一个网络扩大了，而从网络层的角度看，它仍然是通一个网络，一般并不称之为网络互连，网络互联通常是指用路由器进行网络互联和路由选择。

## 常见应用层协议

（HTTP、DNS、FTP、DHCP、SMTP、POP3）

## 项目相关

1、系统问题排查：CPU、内存、网络、数据库瓶颈
2、超卖问题解决思路
3、实现分布式锁
4、大型分布式系统架构设计和调优。分布式系统架构设计：<https://zhuanlan.zhihu.com/p/159745617>
5、分布式架构的基本理论：CAP，BASE
6、设计模式
7、Nginx及负载均衡
8、设计一个秒杀系统。链接：<https://zhuanlan.zhihu.com/p/558395137>
9、成员查询问题 ，Bloom Filter
10、Top k频繁项
11、消息队列；

## 分布式架构下的高可用设计要点

（1）避免单点故障

- 负载均衡技术（failover、选址、硬件负载、软件负载、去中心化负载（gossip（redis-cluster））
- 热备Linux HA
- 多机房（同城灾备，异地灾备）
（2）应用高可用
- 故障监控（系统监控（CPU、内存）、链路监控、日志监控）自动预警
- 应用的容错设计（服务降级，限流）自我保护能力
- 数据量（数据分片，读写分离）
（3）分布式架构下的可伸缩设计
- 垂直伸缩，提升硬件能力
- 水平伸缩，增加服务节点（服务器）
- 加速静态内容（图片，脚本，静态页面等）访问速度的CDN（Content Delivery Network，内容分发网络）

## 秒杀系统设计要点

## Web性能优化

1、DNS查询优化
2、客户端缓存
3、优化TCP连接
4、避免重定向
5、网络边缘的缓存
6、条件缓存
7、压缩和代码极简化
8、图片优化

## 计算机视觉

- 机器学习：
- 人工智能：
- 数据处理和分析展示computer

TensorFlow

## 区块链、元宇宙、NFT

以太坊（Ethereum）是一个去中心化的，运行智能合约的区块链平台。
NFT是元宇宙的确权革命。
NFT是区块链技术的一种应用，NFT是发行在区块链上的差异性数字资产。区块链使数字资产的交易变得更加自由、可信和可靠。
数字化和虚拟化，一定是人类的大势所趋。区块链技术已被普遍认为是下一代互联网技术的核心，区块链为元宇宙的经济系统提供保障，加快元宇宙世界的构建，实现现实世界与虚拟世界的经济互通。而基于区块链的NFT，是通往元宇宙的必经之路，可以在元宇宙中帮助虚拟数字经济的确权，确定元宇宙世界中的社会稳定。
2022年10月18日 10:02:16
X86

## 软件设计八大概念

抽象、体系结构、设计模式、模块化、信息隐藏、功能独立、精化、重构

## 生命科学和生物技术

国家发展改委｜“十四五”生物经济发展规划
规划背景：
（一）发展生物经济的重大意义
是顺应全球生物技术加速演进趋势、实现高水平科技自立自强的重要方向
是前瞻布局培育壮大生物产业、推动经济高质量发展的重要举措
是满足生命健康需求快速增长、满足人民对美好生活向往的重要内容
是加强国家生物安全风险防控、推进国家治理体系和治理能力现代化的重要保障
（二）发展形势
当前，生命科学已成为前沿科学研究活跃领域，生物技术成为促进未来发展的有效力量，生物经济正在勾勒人类社会未来发展的美好蓝图。
党的十八大以来，我国生物经济发展取得巨大成就，产业规模持续快速增长，门类齐全、功能完备的产业体系初步形成，生物领域创新能力大幅提升，生物安全建设取得历史性成就，生物安全政策体系不断完善。"十四五"时期，是生物技术加速演进、生命健康需求快速增长、生物产业迅猛发展的重要机遇期，我国生物经济发展前景广阔。
我国生物经济发展也面临不少挑战，全球疫情仍在持续演变，传统生物安全问题和新型生物安全风险相互叠加，生物产业原创能力仍较为薄弱，生物资源保护开发利用体系尚不完备，生物经济发展缺乏顶层设计和统筹协调等。

# Golang

- 内核
- 内存管理：内存分配、垃圾回收、逃逸分析
- 线程安全
- Golang数据类型
- 引用传递和值传递
- 空struct{}的用途
- `make` 和 `new` 的区别
- 数组和切片的区别
- `for range` 的时候它的地址变化
- 多个 `defer` 的执行顺序，`defer` 在什么时机会修改返回值？
- `uint` 类型溢出
- 介绍 `rune` 类型
- 解析 `tag` 是怎么实现的？反射原理是什么？
- 调用函数传入结构体时，应该传值还是指针？ （`Golang` 都是传值）`context` 结构，使用场景和用途
- `channel` 底层实现原理，是否线程安全，关闭问题？锁用在什么地方？
- `map` 主要特性，使用注意的点，删除一个 `key` 时的内存释放
- `Goroutine` 的并发编程模型基于的GMP模型
- 进程、线程、协程
- `Go` 如何实现原子操作？
- `Mutex` 是悲观锁还是乐观锁
- 并发控制
- `go gc` 是怎么实现的
- 如何优雅地实现一个 `goroutine` 池
- 内存相关：内存泄漏及内存泄漏的排查，内存逃逸，内存分配
- 介绍一下大对象小对象，为什么小对象多了会造成 `gc` 压力？通常小对象过多会导致 `GC` 三色法消耗过多的 `GPU`。优化思路是，减少对象分配。
- `go` 内存管理金字塔结构

## 特点

- 静态类型的编译型语言
- 具有很强的表达能力，它简洁、清晰而高效
- Go代码编译成机器码不仅非常迅速，还具有方便的垃圾收集机制和强大的运行时反射机制
- 益于其并发机制，用它编写的程序能够非常有效地利用多核与联网的计算机
- 其新颖的类型系统则使程序结构变得灵活而模块化
- 作为编程语言的后生，站在巨人的肩膀上，吸收了其他一些编程语言的特点

语言特点：<http://c.biancheng.net/view/3990.html>
详解链接：<https://juejin.cn/post/6844903808753991694>

## 类型（Types）

- 布尔（bool）
- 定长整形，如uint8和int32
- 非定长整形int和uint（32位或64位，取决于机器大小）
- 定长浮点类型（float32和float64）
- 复数类型（complex64和complex128）
- 类似于c语言那样提供了指针、固定大小的数组和结构体类型
- 内置的字符串类型（string）
- 一个被称为map类型的哈希表
- 称为slice类型的动态大小的数组
- Go通过其接口类型提供面向对象的多态性
- Go没有提供类（class），但允许将方法（method）绑定到任何类型上，包括结构体、数组、切片、map，甚至是基本类型，如整数。它没有类型层次体系；继承往往会使程序在演化过程中更难适应。相反，go鼓励类型的组合。

- 并发（Concurrency）：goroutines在一个共享地址空间中运行，并能被有效地通过多路复用机制调度到操作系统线程上

- Select可以用于什么

- 闭包

  - 作用：避免全局变量的滥用
  - 指有权访问另一个函数作用域中的变量的函数
  - 创建闭包的常见方式就是在一个函数内部创建另一个函数，内函数可以访问外函数的变量
  - 注意：闭包里作用域返回的局部变量不会被立刻销毁回收，但过度使用闭包可能会占用更多内存，导致性能下降。
  - 闭包的用法：<https://blog.csdn.net/qq_42696078/article/details/122006956>

- 标准库
  - 常用标准库：<https://www.topgoer.com/常用标准库/>
  - 标准库：<https://studygolang.com/pkgdoc>

Goer：<https://www.topgoer.com/>

- GoLang之Context包的用途是什么
  - Context包，专门用来简化对于处理单个请求的多个goroutine之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个API调用。
  - 详解：<https://blog.csdn.net/weixin_52690231/article/details/124694709>

## 知识点汇总

链接：<https://www.topgoer.cn/docs/gomianshiti/golangInterview>

## 语言规范-编码风格

<https://shockerli.net/post/go-code-guide-style/>
<https://learnku.com/go/wikis/38426>

- 功能实现

  1. 使用Go实现消息队列（多生产者，多消费者）（code）
  使用切片加锁可以实现
  链接：<https://blog.csdn.net/CY2333333/article/details/124493409>

  2. 用golang实现一个定时器任务队列实例（code）
  详解：<https://www.yisu.com/zixun/182743.html>

  3. GOLANG实现crontab定时器功能
  详解：<http://t.zoukankan.com/Yemilice-p-12540258.html>

- Golang中协程退出方式
  - 链接：<https://blog.csdn.net/taw19960426/article/details/124380196>

- 语言特点：

- 全局变量和局部变量

- 闭包(闭包主要是为了避免全局变量的滥用。)

- Printf()、Sprintf()、Fprintf()函数的区别用法是什么

  - 详解：<https://blog.csdn.net/Sunshineoe/article/details/120401167>
- GoLang之Context包的用途是什么
  - Context包，专门用来简化对于处理单个请求的多个goroutine之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个API调用。
  - 详解：<https://blog.csdn.net/weixin_52690231/article/details/124694709>

- 协程调度器原理及GMP设计思想

- 调度器的设计策略
  - 复用线程：避免频繁的创建、销毁线程，而是对线程的复用。
  - work stealing机制：当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。
  - hand off机制：当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。

功能：

内存管理：
1、内存分配：
Golang中也实现了内存分配器，原理与tcmalloc类似，简单的说就是维护一块大的全局内存，每个线程(Golang中为P)维护一块小的私有内存，私有内存不足再从全局申请。
预申请的内存划分为spans、bitmap、arena三部分：
arena即为所谓的堆区，大小为512G，应用中需要的内存从这里分配，为了方便管理把arena区域划分成一个个的page，每个page为8KB,一共有512GB/8KB个页；
spans区域存放span的指针，每个指针对应一个page，所以span区域的大小为(512GB/8KB)*指针大小8byte =512M；span是内存管理的基本单位，next和prev用于将多个span链接起来，有利于管理多个span；
bitmap区域大小也是通过arena计算出来，不过主要用于GC；

为了避免多线程申请内存时不断的加锁，Golang为每个线程分配了span的缓存，这个缓存即是cache；
cache作为线程的私有资源为单个线程服务，而central则是全局资源，为多个线程服务，当某个线程内存不足时会向central申请，当某个线程释放内存时又会回收进central。
每个mcentral对象只管理特定的class规格的span。事实上每种class都会对应一个mcentral,这个mcentral的集合存放于mheap数据结构中，mheap管理着全部的内存，事实上Golang就是通过一个mheap类型的全局变量进行内存管理的。

2、垃圾回收：
常见的垃圾清理算法有：引用计数、标记清除、分代收集；
golang采用三色标记法：
灰色：对象还在标记队列中等待
黑色：对象已被标记，gcmarkBits对应的位为1（该对象不会在本次GC中被清理）
白色：对象未被标记，gcmarkBits对应的位为0（该对象将会在本次GC中被清理）
Stop The World：对于垃圾回收来说，回收过程中也需要控制住内存的变化，否则回收过程中指针传递会引起内存引用关系变化，如果错误的回收了还在使用的内存，结果将是灾难性的。Golang中的STW（Stop The World）就是停掉所有的goroutine，专心做垃圾回收，待垃圾回收结束后再恢复goroutine。STW时间的长短直接影响了应用的执行，时间过长对于一些web应用来说是不可接受的，这也是广受诟病的原因之一。为了缩短STW的时间，Golang不断优化垃圾回收算法（写屏障，），这种情况得到了很大的改善。
垃圾回收触发时机：内存分配量达到阀值，定期触发GC，手动触发
3、逃逸分析
如果分配在栈中，则函数执行结束可自动将内存回收；
如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理;

1. 如果函数外部没有引用，则优先放到栈中；
2. 如果函数外部存在引用，则必定放到堆中；
指针逃逸（Go可以返回局部变量指针，这其实是一个典型的变量逃逸案例）；
栈空间不足逃逸，当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中；
动态类型逃逸：很多函数参数为interface类型，比如fmt.Println(a …interface{})，编译期间很难确定其参数的具体类型，也人产生逃逸。
闭包引用对象逃逸
传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。

线程安全
线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。

GoLang之变量是分配在栈（stack）上还是堆（heap）上？
准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。然而，如果编译器不能确保变量在函数 return 之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上,然而，还要对这些变量做逃逸分析，如果函数 return 之后，变量不再被引用，则将其分配到栈上。
意思是说go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。go语言声称这样可以释放程序员关于内存的使用限制，更多的让程序员关注于程序功能逻辑本身。个人觉得这是扯淡，属于自作主张的小聪明，非常不喜欢这个设计。还是C/C++的逻辑非常清楚：简单逻辑是，声明的局部变量分配在栈，通过动态申请(malloc, new)的内存在堆里。

内存泄露的几种场景
1.大数组放在形参场景下，通常使用切片或者指针进行传递，避免短时间的内存使用激增。
2.定时器的使用（time.Ticker是每隔指定的时间就会向通道内写数据。作为循环触发器，必须调用stop方法才会停止，从而被GC掉，否则会一直占用内存空间）
3.如果Goroutine在执行时被阻塞而无法退出，就会导致Goroutine的内存泄漏，一个Goroutine的最低栈大小为2KB，在高并发的场景下，对内存的消耗也是非常恐怖的！（goroutine的安全退出）
(1)互斥锁未释放；
(2)死锁；
(3)空channel；
(4)能出不能进；
(5)能进不能出；
可以通过 context包 来避免内存（goroutine）泄漏（）

Golang的内存模型，为什么小对象多了会造成gc压力
通常小对象过多会导致 GC 三色法消耗过多的GPU。优化思路是，减少对象分配。

## 触发异常（panic）的场景

- 空指针解析
- 下标越界
- 除数为0
- 调用 panic 函数
- channel已经被关闭，再次关闭会产生panic，这时通过recover使程序恢复正常。（使用sync.Once或互斥锁sync.Mutex确保channel只被关闭一次。）

## 数据类型

Channel：一般用于协程之间的通信，也可以用于并发控制。一个channel只能传递一种类型的值，一个channel同时仅允许被一个goroutine读写；select可以监控多channel，比如监控多个channel，当其中某一个channel有数据时，就从其读出数据。
Channel无缓冲的或者有缓冲的已满，如果不接收数据，会阻塞；
详解：<https://my.oschina.net/u/157514/blog/149192>

Slice：
又称动态数组，依托数组实现，可以方便的进行扩容、传递等，实际使用中比数组更灵活；从数据结构看Slice很清晰，array指针指向底层数组，len表示切片长度，cap表示底层数组容量；使用make来创建Slice时，可以同时指定长度和容量，创建时底层会分配一个数组，数组的长度即容量；
Map：
使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，也即bucket，而每个bucket就保存了map中的一个或一组键值对。当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用链地址法来解决键冲突。由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来；

map如何顺序读取
map不能顺序读取，是因为他是无序的，想要有序读取，首先的解决的问题就是，把key变为有序，所以可以把key放入切片，对切片进行排序，遍历切片，通过key取值。

指针
指针就是变量，用来存放地址的变量（存放在指针中的值都当成地址处理），但是指针的字节长度是固定的。
因为指针保存的是地址，由操作系统的位数决定，32位机的字节是4，64位机的字节是8。

引用传递和值传递
slice在扩容的过程中，会重新创建底层数组，data指向新的数组
所谓值传递，就是实参通过拷贝将⾃⾝内容传递给形参实参通过拷贝将⾃⾝内容传递给形参。也就是将传递的内容拷贝⼀份，给函数；
Slice在扩容过程中，会重新创建底层数组，data指向新的数组。
总结：
1.Go中函数传递都是值传递go中函数传递都是值传递；
2.slice、map、channel都是引⽤类型，即便是值传递，结构内部还是指向原来的引⽤对象，所以函数体内可以直接修改元素；
3.如果slice触发扩容，data会指向新的底层数组，⽽不指向外部的底层数组了。所以之后再修改slice，不会对外部的slice造成影响；

值类型、引用类型
详解：<https://www.jb51.net/article/182727.htm>

空struct{}的用途
空结构体 struct{} 实例不占据任何的内存空间，可以使用 unsafe.Sizeof 计算出一个数据类型实例需要占用的字节数；
golang 空结构体 struct{} 可以用来节省内存；
将 map 作为集合(Set)使用时，可以将值类型定义为空结构体，仅作为占位符使用即可；
不发送数据的信道(channel)。使用 channel 不需要发送任何的数据，只用来通知子协程(goroutine)执行任务，或只用来控制协程并发度。
结构体只包含方法，不包含任何的字段

链接：<https://blog.csdn.net/weixin_44328662/article/details/86501900>

实现Set类型的数据结构（code）
对于Set类型的数据结构，其实本质上跟List没什么多大的区别。无非是Set不能含有重复的Item的特性，Set有初始化、Add、Clear、Remove、Contains等操作。
详解：<https://www.jb51.net/article/170043.htm>

其它：
Go题汇总：
链接：<https://www.topgoer.cn/docs/gomianshiti/golangInterview>

语言规范-编码风格：
<https://shockerli.net/post/go-code-guide-style/>
<https://learnku.com/go/wikis/38426>

开发中遇见的问题：
1.业务逻逻辑不清晰的，需求确定（金地审批业务流）；
2.算法和性能困难的（调整实现方法和逻辑，HTML-TO-PDF下载）；
3.新功能工具刚接触不熟练的，先找官网了解，帖子辅助了解，最后研究讨论（Nacos，Redis，PostGis）；
链接：<https://www.jianshu.com/p/e2ebfc4b80f1>

GO语言高性能编程
链接：<https://geektutu.com/post/hpg-exit-goroutine.html>

Golang中协程退出方式
链接：<https://blog.csdn.net/taw19960426/article/details/124380196>

## context

- 在Go 里，我们不能直接杀死协程，协程的关闭一般会用 channel+select 方式来控制。但是在某些场景下，例如处理一个请求衍生了很多协程，这些协程之间是相互关联的：需要共享一些全局变量、有共同的 deadline 等，而且可以同时被关闭。再用 channel+select 就会比较麻烦，这时就可以通过 context 来实现。简而言之，context 是用来解决 goroutine 之间退出通知、元数据传递的功能库。

- 并发控制和超时控制的标准做法

## 简介

文档目的主要在于引导与发现问题，具体问题需查询相关项目最新文档

- 开发

  - Golang（重点：语言特性、并发编程控制、协程概念、……）
  - 数据处理，做一些脚本工作
  - SQL（重点：关联复杂查询）
  - MySQL（重点：查询优化）
  - Redis（重点：几种数据结构）
  - 网络、计算机网路
  - Linux（重点：常用命令，多路复用Epoll、……）
  - 消息队列（了解、非强项）
  - 分布式系统（了解、非强项）

- 系统优化
  - 数据库、服务、缓存、消息队列、分布式、一致性

- 项目相关

  - 常用关键组件（通用方法、框架（GIN）、工具（））
  - 目录结构
  - 编码规范
  - 接口文档及定义

## 解释型语言、编译型语言

1. C语言在执行前一定要先编译一下，如果发现语法错误，就会发出编译不通过的提示。而C语言就是一种编译型的编程语言.
2. 写完MATLAB代码之后直接点执行就等待结果了，如果有那一句代码发生错误的话，程序就执行到那一句才会停下来报错，所以MATLAB是一种一边执行一边解释的语言，解释是一句一句的翻译。从而不需要预先进行编译，所以称之为解释型语言。

![解释型语言-编译型语言](./img/md/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80-%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80.png)

两种语言的使用场景：

- 编译型语言相对性能好一点，解释型语言跨平台性好一点；
- 编译性语言例如c语言：用c语言开发了程序后，需要通过编译器把程序编译成机器语言（即计算机识别的二进制文件，因为不同的操作系统计算机识别的二进制文件是不同的），所以c语言程序进行移植后，要重新编译。（如windows编译成ext文件，linux编译成erp文件）。
- 解释性语言例如java语言，java程序首先通过编译器编译成class文件，如果在windows平台上运行，则通过windows平台上的java虚拟机（VM）进行解释。如果运行在linux平台上，则通过linux平台上的java虚拟机进行解释执行。所以说能跨平台，前提是平台上必须要有相匹配的java虚拟机。如果没有java虚拟机，则不能进行跨平台。

- 编译型语言代表有：C语言和C++。
- 解释型语言代表有：js,php，MATLAB，java和javascript。

# 消息队列Kafka

消息队列应用场景：解耦、异步、削峰。

Kafka是消息队列中间件的代表产品，它与RocketMQ和RabbitMQ最大的区别在于：在某些场景，可以弃用Flink、Spark这样的计算引擎，借助Kafka Stream轻松实现数据处理。也即，Kafka不仅是消息引擎系统，也是分布式流处理平台。
Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个“按照分布式事务日志架构的大规模发布/订阅消息队列”，这使它作为企业级基础设施来处理流式数据非常有价值。此外，Kafka可以通过Kafka Connect连接到外部系统（用于数据输入/输出），并提供了Kafka Streams——一个Java流式处理库"库 (计算机)")。

网址：<https://zhuanlan.zhihu.com/p/74063251>

解决的问题：解耦、异步、削峰
架构中引入MQ后存在的问题：
降低系统可用性。如果MQ挂掉，导致整个系统崩溃；
系统复杂性变高。可能发重复消息，导致插入重复数据；消息丢了；消息顺序乱了；系统 B，C，D 挂了，导致 MQ 消息积累，磁盘满了；
一致性问题。本来应该A，B，C，D 都执行成功了再返回，结果A，B，C 执行成功 D 失败。
建议：中小型公司 RabbitMQ，大公司：RocketMQ，大数据实时计算：Kafka。
解决方案：
事务机制：（一般不采用，同步的，生产者发送消息会同步阻塞卡住等待你是成功还是失败。会导致生产者发送消息的吞吐量降下来）；
持久化到磁盘；
知识点：<https://wenku.baidu.com/view/36c47b5a32b765ce0508763231126edb6f1a76a9.html>
链接：<https://zhuanlan.zhihu.com/p/356235333>
Go语言系列之RabbitMQ消息队列：<https://blog.51cto.com/u_13919520/3153035>
消息队列对比详解：<https://baijiahao.baidu.com/s?id=1708572554459077699&wfr=spider&for=pc>

# Linux

- IO
- 内核空间、用户空间（内核态、用户态）
  - 内核空间就是操作系统内核代码运行使用的内存空间
  - 用户空间就是用户程序代码运行使用的内存空间
  - 因为操作系统太高级，我们用户组所有的应用，是运行在操作系统之上的，一旦操作系统不能稳定运行，那就完了。而保证操作系统运行稳定的基础，就是操作系统所使用的内存不能被随意更改，所以内存被虚拟的分成了用户内存和内核内存。
- Linux基本组件：内核、shell和GUI、系统实用程序和应用程序；
- Linux开机启动过程
  1. 主机加电自检，加载BIOS硬件信息；
  2. 读取MBR的引导文件（GRUB、LILO）；（LILO：是Linux的引导加载程序，主要用于将Linux操作系统加载到主内存中，以便它可以开始运行）
  3. 引导Linux内核；
  4. 运行第一个进程init（进程号永远是1）；
  5. 进入相应的运行级别；
  6. 运行终端，输入用户名和密码；
- Linux使用的进程间通信方式
  - 管道（pipe）、流管道（s_pipe）、有名管道（FIFO）；
  - 信号（signal）；
  - 消息队列；
  - 共享内存；
  - 信号量；
  - 套接字（socket）；
- 系统日志文件
  - 比较重要的是 /var/log/messages 日志文件，该日志文件是许多进程日志的汇总，从该文件可以看出任何企图或成功的入侵；
- 交换空间：是Linux使用的一定空间，用于临时保存一些并发运行的程序。当RAM没有足够的内存来容纳正在执行的所有程序时，就会发生这种情况；
- 硬链接和软连接
- [常使用命令](https://zhuanlan.zhihu.com/p/455887180>)
- 孤儿进程，僵尸进程(父进程回收，内部引用进程没有关闭，导致孤儿进程和僵尸进程)
- 死锁条件，如何避免(互相引用会导致死锁现象发生，避免互相引用情况发生)
- 学习Linux的三步走
  1. 了解 Linux 的基本概念，会敲常用命令来应对工作。从事开发和运维岗位的同学。
  2. 能理解 Linux 尤其是其内核的设计思想，能将其思想应用到系统的架构设计中。
  3. 熟知 Linux 的使用、思想和细节，更能推陈出新，自主创造新的系统。
- 网络资源
  > 操作系统：<https://xiaolincoding.com/os>
  > 牛客网Linux专项练习：<https://www.nowcoder.com/exam/intelligent>
  > Linux自学资源：<https://github.com/0voice/linux_kernel_wiki>
  > Linux 常用命令：<https://www.runoob.com/linux/linux-command-manual.html>

## Nginx（一个集**静态资源**、**负载均衡**于一身的**Web**服务器）

Nginx是当下最流行的Web[服务器](https://cloud.tencent.com/product/cvm?from=10680)，通过官方以及第三方C模块，以及在Nginx上构建出的Openresty，或者在Openresty上构建出的Kong，你可以使用Nginx生态满足任何复杂Web场景下的需求。Nginx的性能也极其优秀，它可以轻松支持百万、千万级的并发连接，也可以高效的处理磁盘IO，因而通过静态资源或者缓存，能够为Tomcat、Django等性能不佳的Web应用扛住绝大部分外部流量。

## 都是事件驱动，为什么Nginx的性能远高于Redis？

谈到Redis缓存，我们描述其性能时会这么说：支持1万并发连接，几万QPS。而我们描述Nginx的高性能时，则会宣示：支持C10M（1千万并发连接），百万级QPS。Nginx用C语言开发，而Redis是用同一家族的C++语言开发的，C与C++在性能上是同一级数的。Redis与Nginx同样使用了事件驱动、异步调用、Epoll这些机制，为什么Nginx的并发连接会高出那么多呢？

这其实是由**进程架构**决定的。为了让进程占用CPU的全部计算力，Nginx充分利用了分时操作系统的特点，比如增加CPU时间片、提高CPU二级缓存命中率、用异步IO和线程池的方式回避磁盘的阻塞读操作等等，只有清楚了Nginx的这些招数，你才能将Nginx的性能最大化发挥出来。

材料、散热这些基础科技没有获得重大突破前，CPU频率很难增长，类似Redis、NodeJS这样的单进程、单线程高并发服务，只能向分布式集群方向发展，才能继续提升性能。Nginx通过Master/Worker多进程架构，可以充分使用服务器上百个CPU核心，实现C10M。

为了榨干多核CPU的价值，Nginx无所不用其极：通过绑定CPU提升二级缓存的命中率，通过静态优先级扩大时间片，通过多种手段均衡Worker进程之间的负载，在独立线程池中隔离阻塞的IO操作，等等。可见，高性能既来自于架构，更来自于细节。

## Etcd-服务发现

[etcd](https://etcd.io/)（读作 et-see-dee）是一种[开源的](https://www.redhat.com/zh/topics/open-source/what-is-open-source)分布式统一键值存储，用于分布式系统或计算机集群的共享配置、服务发现和的调度协调。etcd 有助于促进更加安全的自动更新，协调向主机调度的工作，并帮助设置[容器](https://www.redhat.com/zh/topics/containers/whats-a-linux-container)的覆盖网络。

etcd 是许多其他项目的核心组件。最值得注意的是，它是 [Kubernetes](https://www.redhat.com/zh/topics/containers/what-is-kubernetes) 的首要数据存储，也是[容器编排](https://www.redhat.com/zh/topics/containers/what-is-container-orchestration)的实际标准系统。使用 etcd， [云原生应用](https://www.redhat.com/zh/topics/cloud-native-apps)可以保持更为一致的运行时间，而且在个别服务器发生故障时也能正常工作。应用从 etcd 读取数据并写入到其中；通过分散配置数据，为节点配置提供冗余和弹性。

服务发现（Service discovery）是自动检测一个[计算机网络](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C "计算机网络")内的设备及其提供的服务。服务发现议定(service discovery protocol)帮助发现服务的[网络传输协议](https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE "网络传输协议")。服务发现的目的在于为用户自行配置而减负。服务发现通常需要一个共同的语言, 帮助用户通过软件代理器（software agents）调用另一个服务, 而不需要用户自行调用。

## Nacos-动态服务发现、配置管理和服务管理的平台

1、Nacos 是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理的平台；

## 微服务

微服务是架构设计方式，分布式是系统部署方式，两者概念不同
是什么：
微服务是一种软件开发技术，是面向服务的体系结构（SOA）架构样式的一种变体，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值；
每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）；

## SOA架构

面向服务的架构（Service Oriented Architecture）；
它是一种设计方法，其中包含多个服务， 服务之间通过相互依赖最终提供一系列的功能；

## ESB（企业服务总线）、微服务API网关

简单来说 ESB 就是一根管道，用来连接各个服务节点。为了集成不同系统，不同协议的服务，ESB 做了消息的转化解释和路由工作，让不同的服务互联互通；
API网关是一个服务器，是系统的唯一入口。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。
链接：<https://www.cnblogs.com/xuwc/p/13989081.html>

## 数据库

### 索引

索引是数据库表中一列或者多列的值进行排序后的一种结构，其作用就是提高表中数据的查询速度。类似于字典中的音序表；
索引类型：
1.主键索引（primary key）：保证数据的唯一性，不能为空，唯一标识数据库表中的每条记录（alter table table_name add primary key（column）;）
2.唯一索引（unique）：唯一索引，防止数据出现重复（alter table table_name add unique（column）;）
3.普通索引（index）：仅仅是为了提高查询的速度（alter table table_name add index_name（column）;）
4.联合索引（）：
5.全文索引（）：

索引简单来讲就是查询数据的优化方案，通过提取数据的特征信息，通过特征信息快速定位到原始数据。
类似的设计方案：
1.数组：通过下标计算元素的具体地址，然后通过地址获取数据，通过下标计算真实的地址其实也算是一种索引技术；
2.MySQL的B+树索引，通过索引减少查询磁盘的次数，提高查询效率，这是索引的经典场景；
3.ES的倒排索引；
4.Java中的Map其实也是索引技术的经典实现；

### 联合索引

链接：<https://blog.csdn.net/w13346019869/article/details/123413536>

### MySQL全文索引

全文索引与普通的索引不是一回事，在查找上方面其效率是普通模糊（like）查询和N倍，是MySQL专门提供用作搜索引擎的；
只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引；
全文索引有专用的查询语法：match(字段) against(关键字)。如：select * from answer where match(content) against("测试表")；
连接：<https://zhuanlan.zhihu.com/p/417229576>

### 哈希索引和B + 树索引

针对查询效率而言，哈希索引最快，如果不存在哈希碰撞，效率为O（1）；
但是B+树索引可以范围查询，而哈希索引不行；
使用场景：
1.大多数场景下，都会有组合查询，范围查询、排序、分组、模糊查询等查询特征，Hash 索引无法满足要求，建议数据库使用B+树索引。
2.在离散型高，数据基数大，且等值查询时候，Hash索引有优势。

### SQL查询

示例：<https://www.w3school.com.cn/sql/sql_groupby.asp>
左查询和右查询：<https://baijiahao.baidu.com/s?id=1728618861730351587&wfr=spider&for=pc>

## 分布式（技术）

一种基于网络的计算机处理技术，与集中式相对应。
分布式网络中，数据的存储和处理都是在本地工作站上进行的。因为每台计算机都能够存储和处理数据，所以不要求服务器功能十分强大，其价格也就不必过于昂贵。同时允许他们共享网络的数据、资源和服务。在分布式网络中使用的计算机既能够作为独立的系统使用，也可以把它们连接在一起得到更强的网络功能。
分布式技术优点：
快速访问、多用户使用，每台计算机都可以访问系统内其他计算机的信息文件；
系统设计上具有更大的灵活性，既可为独立的计算机的地区用户的特殊需求服务，也可为联网的企业需求服务，实现系统内不同计算机之间的通信；
分布式技术缺点：
对病毒比较敏感，任何用户都可能引入被病毒感染的文件，并将病毒扩散到整个网络；
备份困难，如果用户将数据存储在各自的系统上，而不是将他们存储在中央系统中，难于制定一项有效的备份计划。这种情况还可能导致用户使用同一文件的不同版本。
设备必须要互相兼容。
管理和维护比较复杂。
百度百科：<https://baike.baidu.com/item/分布式技术/4110919>

分布式计算：hadoop、HBase
MapReduce原理简介：<https://zhuanlan.zhihu.com/p/62135686>
Hbase简介：<https://blog.csdn.net/u012485099/article/details/110941341>
Hadoop百科：<https://baike.baidu.com/item/Hadoop/3526507?fr=aladdin>
Hive百科：<https://baike.baidu.com/item/hive/67986?fr=aladdin>

### Hadoop

Hadoop是一个分布式系统基础架构。可以使得用户在不用了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储；

### HDFS

HDFS是指被设计成适合运行在通用硬件上的分布式文件系统；
具有高容错性特点（多备份机制），并且提供高吞吐量来访问应用程序的数据（流式访问），适合那些超大数据集的应用程序；
HDFS采用了主从（Master/Slave）结构模型，一个HDFS集群是由一个NameNode和若干个DataNode组成的。其中NameNode作为主服务器，管理文件系统的命名空间和客户端对文件的访问操作；集群中的DataNode管理存储的数据；

### Hbase

Hbase是一种分布式、可扩展、支持海量数据存储的NoSQL数据库；

### Hive

hive是基于Hadoop的一个数据仓库工具，用来进行数据提取、转化、加载，这是一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制；
Hive 的本质其实就相当于将HDFS 中已经存储的文件在Mysql中做了一个双射关系，以方便使用 HQL 去管理查询；

### MapReduce

MapReduce是一种分布式计算框架 ，以一种可靠的，具有容错能力的方式并行地处理TB级别的海量数据集。主要用于搜索领域，解决海量数据的计算问题。
YARN：
是一种新的 Hadoop 资源管理器，它是一个通用资源管理系统，可为上层应用提供统一的资源管理和调度，它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。

### 分布式系统

建立在网络之上的软件系统
链接：<https://baike。baidu。com/item/分布式系统/4905336>
分布式相关知识点：
1.CAP原则：一致性、可用性、分区容忍性（只能满足两个）；
2.分布式一致性协议raft，两大核心：选主和复制日志；
3.一致性哈希算法，保证负载均衡，可添加虚拟节点；
4.大型网站系统架构：用户-负载均衡器-N台服务器-redis缓存集群-mysql集群
(1)前端限流（例如一个用户10秒内只能点击一次，异步处理，消息队列）；
(2)负载均衡一般采用NGINX反向代理；
(3)mysql读写分离，主库写，从库读，分库分表。
5.准点秒杀设计：承受高并发的压力，采用前端限流，削峰（异步处理，消息队列）的方法；
6.分布式锁ZooKeeper：在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要互斥来防止彼此干扰来保证一致性，在这种情况下，便需要使用到分布式锁。
7.分布式缓存：
8.微服务：优点：松耦合，开发容易，职责单一，可以技术异构；缺点:可能会重复开发，各个微服务之间维护复杂，通讯耗时长；
9.消息队列：
10.数据库缓存一致性：保证redis和mysql的一致性；
(1)先删缓存，再更新数据库；
(2)一般采用延时双删策略，即先删缓存，更新数据库，休眠1秒，再删缓存。第二次删除缓存为异步。如果第二次删缓存失败，还会有缓存和数据库不一致的问题。可以引入保障机制，删除失败重新删除，直到成功。
11.数据库主从一致性；
12.缓存雪崩，缓存穿透；
链接：<https://zhuanlan.zhihu.com/p/140272240>

# 项目

## 集群

- 核心技术：任务调度
- 优势：在付出较低成本的情况下获得在性能、可靠性、灵活性方面的相对较高的收益
- 本质：是一组相互独立的、通过高速网络互联的计算机，它们构成了一个组，并以单一系统的模式加以管理。一个客户与集群相互作用时，集群像是一个独立的服务器。
- 使用场景：提高服务的可用性和可缩放性

- 分类：（1）科学计算：以集群开发的并行应用程序，可以解决复杂的科学问题，科学集群对外好像一个超级计算机。（2）负载均衡集群：使用特定的算法，使得应用程序处理负载或网络流量负载尽可能平均分摊处理，以实现负载均衡。（3）高可用性能集群：考虑到计算机硬件和软件的易错性，高可用性能集群的主要目的是为了使集权的服务尽可能可用。当主节点发生了故障，那么这段时间内将有次节点代替它，次节点主要是主节点的镜像。当它代替主节点时，它可以完全接管其身份，因此使系统环境对用户是一致的。

## 高性能、高并发

- [秒杀系统设计](https://blog.csdn.net/weixin_45953989/article/details/120016954)

- [C10K问题及解决方案](https://cloud.tencent.com/developer/article/1031629)
- C10k问题是优化网络套接字以同时处理大量客户端的问题；

## 白盒测试、黑盒测试

- 白盒测试：也称为结构测试，主要用于检测软件编码过程中的错误。程序员的编程经验、对编程软件的掌握程度、工作状态等因素都会影响到编程质量，导致代码错误。
- 黑盒测试：又称为功能测试，主要检测软件的每一个功能是否能够正常使用。在测试过程中，将程序看成不能打开的黑盒子，不考虑程序内部结构和特性的基础上通过程序接口进行测试，检查程序功能是否按照设计需求以及说明书的规定能够正常打开使用。

## 跨域、同源、同源策略、跨域资源共享

- 同源策略（Same Orgin Policy）、跨域资源共享（Cross-origin resource sharing，CORS）
- 首先一个url是由：协议（protocol）、主机（host）和端口号（port）三部分组成。（一般端口默认80），如：`https://blog.moonlet.cn:80`，当一个请求url的协议、域名、端口三者之间的任意一个与当前页面url不同即为跨域，三者相同即为同源。
- 同源策略：它是一种约定，它是浏览器核心也最基本的安全功能，它会阻止一个域的js脚本和另外一个域的内容进行交互，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。
- 跨域资源共享：用于让网页的受限资源能够被其他域名的页面访问的一种机制，通过该机制，页面能够自由地使用不同源（cross-origin）的图片、样式、脚本、iframes以及视频。一些跨域的请求（特别是Ajax）常常会被同源策略（Same-origin policy）所禁止的。跨源资源共享定义了一种方式，为的是浏览器和服务器之间能互相确认是否足够安全以至于能使用跨源请求（cross-origin requests）。比起纯粹的同源请求，这将更为自由和功能性的（functionality），但比纯粹的跨源请求更为安全。跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同网域传来沙盒("沙盒 (电脑安全)")脚本的方法，以避开浏览器的同源策略。

# 网络

- [OSI七层模型](#osi七层模型)
- [TCP/IP四层抽象协议](#tcpip四层抽象协议)
- [HTTP、HTTPS](#httphttps)
- [OSI七层模型](#osi七层模型)
- [OSI七层模型](#osi七层模型)
- [OSI七层模型](#osi七层模型)

## OSI七层模型

1.物理层：比特流传输；
2.数据链路层：提供介质访问、链路管理等；
3.网络层：寻址和路由选择；
4.传输层：建立主机端到端连接；
5.会话层：建立、维护和管理会话；
6.表示层：处理数据格式，数据加密等；
7.应用层：提供应用程序间通信；

## TCP/IP四层抽象协议

TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中：
1.应用层：TFTP, HTTP, SNMP, FTP, SMTP, DNS, Telnet等等；
2.传输层：TCP, UDP
3.网络层：IP, ICMP, OSPF, EIGRP, IGMP
4.数据链路层：SLIP, CSLIP, PPP, MTU
每一抽象层建立在低一层提供的服务上，并且为高一层提供服务；

## HTTP、HTTPS

（Hyper Text Transfer Protocol）超文本传输协议

- 它是运行在TCP之上的一种应用层协议。
- HTTP是一种无状态协议，即服务器不保留与客户交易时的任何状态。
- HTTP支持持久连接。

HTTPS 协议提供了三个关键的指标：

1. 加密(Encryption)， HTTPS 通过对数据加密来使其免受窃听者对数据的监听，这就意味着当用户在浏览网站时，没有人能够监听他和网站之间的信息交换，或者跟踪用户的活动，访问记录等，从而窃取用户信息。
2. 数据一致性(Data integrity)，数据在传输的过程中不会被窃听者所修改，用户发送的数据会完整的传输到服务端，保证用户发的是什么，服务器接收的就是什么。
3. 身份认证(Authentication)，是指确认对方的真实身份，也就是证明你是你（可以比作人脸识别），它可以防止中间人攻击并建立用户信任。

## DNS（Domain Name System）域名系统

- 是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。
- 一般来说像我们访问的地址都叫做域名，而众所周知网络中的任何一个主机都是IP地址来标识的，也就是说只有知道了这个站点的IP地址才能够成功实现访问操作，不过由于IP地址信息不太好记忆，所以网络中出现了域名这个名字，在访问时我们只需要输入这个好记忆的域名即可，网络中会存在着自动将相应的域名解析成IP地址的服务器，这就是DNS服务器。

## JWT

Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。

最常见的应用场景是：

- 微服务框架下，多种语言服务之间的高效交互。
- 将手机服务、浏览器连接至后台
- 产生高效的客户端库

攻击、DDOS攻击、网站数据库注入

## DDOS攻击（DDoS:Distributed Denial of Service）分布式拒绝服务

- 利用目标系统网络服务功能缺陷或者直接消耗其系统资源，使得该目标系统无法提供正常的服务。

## CC攻击（Challenge Collapsar）挑战黑洞

- CC攻击的原理是通过代理服务器或者大量肉鸡模拟多个用户访问目标网站的动态页面，制造大量的后台数据库查询动作，消耗目标CPU资源，造成拒绝服务。

## DDoS和CC的区别

- DDoS攻击打的是网站的服务器，而CC攻击是针对网站的页面攻击的。一个是WEB网络层拒绝服务攻击（DDoS），一个是WEB应用层拒绝服务攻击（CC）
- 网络层就是利用肉鸡的流量去攻击目标网站的服务器，针对比较本源的东西去攻击，服务器瘫痪了，那么运行在服务器上的网站肯定也不能正常访问了。而应用层就是我们用户看得到的东西，就比如说网页，CC攻击就是针对网页来攻击的，CC攻击本身是正常请求，网站动态页面的正常请求也会和数据库进行交互的，当这种"正常请求"达到一种程度的时候，服务器就会响应不过来，从而崩溃。
- DDoS是针对IP的攻击，而CC攻击的是服务器资源

# 网络编程（Socket/TCP、UDP/HTTP、RPC）

## Socket（套接字）

- 在计算机通信领域，它是计算机之间通信的一种约定或一种方式。通过socket这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据；
- Socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open --> 读写write/read --> 关闭close”模式来操作。即socket是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO，打开，关闭）。Socket（）函数返回一个整型的Socket描述符，随后的连接建立、数据传输等操作都是通过该Socket实现的。

## Socket怎么通信

如何利用三元组（IP地址、协议、端口）实现网络通信，Socket就是利用三元组解决网络通信的一个中间件工具，就目前而言，几乎所有的应用程序都是采用Socket。
Socket通信的数据传输方式，常用的有两种：
1.SOCK_STREAM：表示面向连接的数据传输方式。数据可以准确无误的到达另一台计算机，如果损坏或者丢失，可以重新发送，但效率相对比较慢。常见的http协议就是使用SOCK_STREAM传输数据，因为要确保数据的正确性，否则网页不能正常解析；
2.SOCK_DGRAM：表示无连接的数据传输方式。计算机只管传输数据，不做数据校验，如果数据在传输中损坏、或者没有到达另一台计算机，是没办法补救的。也就是说，错了就是错了，无法重传。因为SOCK_DGRAM所做的校验工作少，所以效率比SOCK_STREAM高；

## HTTP

HTTP客户端状态码含义：
400 bad request，请求报文存在语法错误
401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
403 forbidden，表示对请求资源的访问被服务器拒绝
404 not found，表示在服务器上没有找到请求的资源

HTTP：keep-alive
client发出的HTTP请求头需要增加Connection:keep-alive字段
Web-Server端要能识别Connection:keep-alive字段，并且在http的response里指定Connection:keep-alive字段，告诉client，我能提供keep-alive服务，并且"应允"client我暂时不会关闭socket连接

http能不能一次连接多次请求，不等后端返回
http本质上是用socket连接，因此发送请求，接写入tcp缓冲，是可以多次进行的，这也是http是无状态的原因；
HTTP无状态协议，是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传；
但为了为支持客户端与服务器之间的交互，我们就需要通过不同的技术为交互存储状态，而这些不同的技术就是Cookie和Session了。

## TCP协议

Transmission Control Protocol （传输控制协议）是一种面向连接（连接导向）的、可靠的、基于IP的传输协议。
通过排序（保证数据的读取是按照正确的格式进行）和重传（保证数据能准确传输到目的地）来确保数据传输的可靠性（即数据的准确传输以及完整性）；
握手详解：<https://blog.csdn.net/Jalon2015/article/details/115219026>
Time Wait的做用：
防止上一次连接中的分段延迟到达后影响新连接，TIME_WAIT状态持续2MSL后，原连接的数据包都已经在网络上消失，不会再干扰新连接。
链接：<https://blog.csdn.net/iCode_girl/article/details/108595066>

## TCP/IP协议

- TCP/IP（TCP（传输控制协议）和IP（网际协议））提供点对点的链接机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。
- 它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，被分别归属到这四个层次结构之中，常被视为简化的七层OSI模型。
- TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据传输前要建立连接，传输完毕后还要断开连接，客户端在收发数据前要使用 connect（）函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据传输开辟通道。

TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话：

1. Shake 1 ：套接字A：“你好，套接字B，我这边有数据要传给你，建立连接吧。”
2. Shake 2 ：套接字B：“你好，我这边已经准备就绪。”
3. Shake 3 ：套接字A：“谢谢你受理我的请求。”

TCP四次握手断开连接，建立连接是数据正确传递的前提，断开连接同样重要，它能让计算机释放不再使用的资源。断开连接可以形象如下比喻：

1. Shake 1 ：套接字A：“任务处理完毕，我希望断开连接。”
2. Shake 2 ：套接字B：“哦，是吗？请稍等，我准备一下。”
3. Shack 3 ：套接字B：“我准备好了，可以断开连接了。”
4. Shake 4 ：套接字A：“好的，谢谢合作。”
TIME_WAIT状态：
如何优雅的断开连接：
TCP的粘包问题以及数据的无边界性：
TCP数据报结构

6、Socket常用函数接口及其原理：
Server：
1.socket（）：创建Socket；
2.Bind（）：绑定socket和端口号；
3.Listen（）：监听端口号；
4.Accept（）：接收来自客户端的连接请求；
5.Recv（）：从socket中读取字符；
6.close（）：关闭socket；
Client：
1.Socket（）：创建socket；
2.Connect（）：连接指定计算机的端口；
3.Send（）：向socket中写入信息；
4.Close（）：关闭socket；

Socket缓冲区以及阻塞模式：
Socket整文参考链接：<https://www.jianshu.com/p/066d99da7cbd>

## RPC

进程间通信（IPC）：
进程间通信是多任务操作系统或联网的计算机之间运行的程序所用的通信技术。
进程间通信技术有两种类型：
1.本地过程调用（LPC）：LPC用在多任务操作系统中，使得同时运行的任务能互相会话。这些任务共享内存使任务同步或者互发信息；
2.远程过程调用（RPC）：RPC类似于LPC，只是在网上工作；
通过LPC或者RPC，程序能利用其它程序或计算机处理的进程；
远程过程调用（RPC）跨越了开放系统互连（OSI）网络通信模型中的传输层和应用层。远程过程调用使得开发应用程序更容易。
客户端/服务器通信的替代方法包括信息队列和IBM的高级程序间通信（APPC）。
RPC在分布式系统中的系统环境建设和应用程序设计中的应用包括：
1.分布式操作系统的进程间通讯；
2.构造分布式计算的软件环境；
3.远程数据库服务（用户在客户端使用RPC模式调用存储过程）；

## Socket、RPC、gRPC

- RPC（Remote Procedure Call，远程过程调用）是建立在Socket之上的，它比socket需要更多的网络和系统资源。越底层，代码越复杂、灵活性越高、效率越高；越上层，抽象封装的越好、代码越简单、效率越差。Socket和RPC的区别再次说明了这点。

- 合格RPC框架功能：服务发现、负载均衡、容错
- 流程：服务提供端 Server 向注册中心注册服务，服务消费者 Client 通过注册中心拿到服务相关信息，然后再通过网络请求服务提供端 Server
- 组成部分
  1. 注册中心：Zookeeper（推荐）、Nacos、Redis、ETCD；
  2. 网络传输：使用 Socket （但是，Socket 是阻塞 IO、性能低并且功能单一）；
  3. 序列化和反序列化：
- gRPC
  - google发起的一个开源，基于 HTTP/2协议传输，使用Protocol Buffers作为接口描述语言。
  - 使用Protocol Buffers作为序列化协议。它是一种与语言、平台无关 、可扩展的序列化结构数据。它的定位类似于JSON、XML，但是比他们更小、更快、更简单。
  - HTTP/2相比HTTP1.x优势：
    1. 用于数据传输的二进制分帧；
    2. 多路复用（HTTP/2支持通过同一个连接发送多个并发的请求）；
    3. 服务端推送（在HTTP/2中，服务器可以对客户端的一个请求发送多个响应）；
    4. 减少网络流量的头部压缩；

## 网络中进程的通信方式

Socket主要是用来解决网络通信的，那网络中的进程是如何通信的呢？

## 本地进程间通信

1. 消息队列（管道、消息队列、FIFO）；
2. 同步（互斥量、条件变量、读写锁、文件和写记录、信号量）；
3. 共享内存（匿名的和具名的，eg：channel）；
4. 远程过程调用（RPC）；

## 网络中如何通信

两个待解决问题：1、如何标识一台主机；2、如何标识唯一进程，本地通过pid，网络中如何标识；
解决办法：
1.TCP/IP协议可以通过网络层的“IP地址”唯一标识网络中的主机；
2.传输层的“协议+端口”可以唯一标识主机中的应用程序（进程），因此，利用三元组（IP地址，协议，端口）就可以标识网络中的进程，网络中的进程通信就是利用这个标志与其它进程交互；

点对点技术又称对等互联网络技术，是一种网络新技术，依赖网络中参与者的计算能力和带宽，而不是把依赖都聚集在较少的几台服务器上.

## CSRF与XSS

- XSS 攻击：跨站脚本攻击(Cross Site Scripting)，恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。

- CSRF 攻击：CSRF（Cross-site request forgery）跨站请求伪造，是一种对网站的恶意利用

## 短连接与长连接

当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。

## 浏览器键入URL后的访问流程

- 浏览器使用DNS协议向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址，其中DNS服务器是基于UDP的，因此会用到UDP协议;
- 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接，会使用到TCP协议;
- 然后浏览器就要与服务器建立一个http连接，因此要用到http协议，http生成一个get请求报文，如果采用https还会使用https协议对http数据进行加密，涉及到SSL协议，将报文发送到TCP层
- TCP层如果有需要先将HTTP数据包分片，分片依据MTU和MSS（ mtu是网络传输最大报文包,mss是网络传输数据最大值）。
- TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。
- 当然在一个网段内的寻址是通过以太网协议实现，以太网协议需要知道目的IP地址的物理地址，则需要ARP协议。
- 服务器端接收到请求，然后发送返回响应请求
- 释放 TCP连接(若connection为close，则释放TCP连接，若为keep-alive则不会释放);
- 浏览器将该解析html文本并显示内容

## ARP协议

ARP协议的用途是为了从网络层使用的IP地址，解析出数据链路层使用的硬件地址。

- 在主机ARP高速缓存中存放一个从IP地址到硬件地址的映射表
- 当需要解析时，先去arp缓存表(存着ip-mac对应关系)去查找目标ip的mac地址
- 如果查到了，将目标ip的mac地址封装到链路层数据报
- 如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX，所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单播的形式将自己的mac地址回复给请求的机器

## DNS域名解析的工作过程和原理

- DNS解析有两种方式：递归查询和迭代查询
- DNS采用UDP传输

## DNS解析（DNS找IP）

1. 当浏览器中输入www.bai.com域名时，操作系统会检查自己本地的hosts文件查看是否有这个网址的映射关系，如果有，直接调用
2. 如果没有，则查找本地的DNS解析器缓存，如果有，则直接返回IP
3. 如果没有，再找TCP/IP参数中设置的本地的DNS服务器，如果该域名包含再本地配置区域的资源中，则返回解析结果。
4. 也可能查找的域名，本地的DNS服务器已经缓存在网址的映射关系，那么直接调用这个IP
5. 如果本地DNS服务器也无法解析，会根据本地的DNS服务器是否设置转发器进行查询

如果是未转发模式，本地DNS会把请求发给13台根DNS，由对应的根服务器（例如.com）向下找，最后完成解析。如果是转发模式，那么DNS服务器会把请求一级一级向上传，往上找，直到传到根DNS。

- 网络分层：简化网络设计的复杂性，增加灵活性和标准制定

## ip地址、子网掩码

- IP地址：电脑IP，可以说是网络上的电脑识别号，有IP的电脑才能上网，方便大家的交流和寻找作用
- 子网掩码：互联网是由许多小型网络构成的，每个网络上都有许多主机，这样便构成了一个有层次的结构。IP地址在设计时就考虑到地址分配的层次特点，将每个IP地址都分割成网络号和主机号两部分，以便于IP地址的寻址操作

子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。

- 默认网关：一个网络就必须有网关，也就是internet网进入一个集体、或个体网络的最先接连者，有它我们的信息将能更好的得到规划。
- 网关:只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信
- 网络号:用ip地址和子网掩码的二进制数进行“与”运算即可得出网络号。
- 广播地址(Broadcast Address)是专门用于同时向网络中所有工作站进行发送的一个地址。

## TCP协议(可靠的传输协议)

(1)TCP相关概念
(2)确认应答机制
(3)超时重传机制(安全机制)
(4)连接管理机制（安全机制）
(5)滑动窗口（效率）
(6)流量控制机制（安全机制）
(7)拥塞控制机制（安全机制）
(8)延迟应答机制(效率)
(9)捎带机制（效率）

TCP的总结
(1)TCP特性
(2)面向字节流
(3)粘包问题

# 格式化

- 命名规范，包括常量、变量、方法命、文件名、文件夹……（驼峰、蛇形）
- 代码格式：缩进、空格、空行、注释
- 错误处理：打印、写入文档、统一规范处理
- 安全、循环引用、导入、全局、私有、临时

[Google](https://www.google.com/ "这是鼠标悬浮文案")

[Uber开源的《Go语言编码规范》](https://github.com/xxjwxc/uber_go_guide_cn/ "Uber 开源的《Go 语言编码规范》")

# 数据结构及算法

## 常见数据结构（data structure）

- 栈（Stack）：栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。
- 队列（Queue）：队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。
- 数组（Array）：数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。
- 链表（Linked List）：链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。
- 树（Tree）：树是典型的非线性结构，它是包括，2 个结点的有穷集合 K。
- 图（Graph）：图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。
- 堆（Heap）：堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。
- 散列表（Hash table）：散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。

## 常见算法

数据结构研究的内容：就是如何按一定的逻辑结构，把数据组织起来，并选择适当的存储表示方法把逻辑结构组织好的数据存储到计算机的存储器里。算法研究的目的是为了更有效的处理数据，提高数据运算效率。数据的运算是定义在数据的逻辑结构上，但运算的具体实现要在存储结构上进行。一般有以下几种常用运算：

- 检索：检索就是在数据结构里查找满足一定条件的节点。一般是给定一个某字段的值，找具有该字段值的节点。
- 插入：往数据结构中增加新的节点。
- 删除：把指定的结点从数据结构中去掉。
- 更新：改变指定节点的一个或多个字段的值。
- 排序：把节点按某种指定的顺序重新排列。例如递增或递减。

链接：<https://cloud.tencent.com/developer/article/1404952>
