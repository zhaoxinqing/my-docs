
# 跨域、同源

首先一个url是由：协议、域名、端口三部分组成。（一般端口默认80），如：<https://blog.moonlet.cn:80>
当一个请求url的协议、域名、端口三者之间的任意一个与当前页面url不同即为跨域，三者相同即为同源。

## 同源策略（Same Orgin Policy）

所谓同源（即在同一个域）就是两个页面具有相同的协议（protocol）、主机（host）和端口号（port）。
它是一种约定，它是浏览器核心也最基本的安全功能，它会阻止一个域的js脚本和另外一个域的内容进行交互，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。

## CORS（Cross-origin resource sharing）跨域资源共享

用于让网页的受限资源能够被其他域名的页面访问的一种机制，通过该机制，页面能够自由地使用不同源（cross-origin）的图片、样式、脚本、iframes以及视频。一些跨域的请求（特别是Ajax）常常会被同源策略（Same-origin policy）所禁止的。跨源资源共享定义了一种方式，为的是浏览器和服务器之间能互相确认是否足够安全以至于能使用跨源请求（cross-origin requests）。比起纯粹的同源请求，这将更为自由和功能性的（functionality），但比纯粹的跨源请求更为安全。
跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同网域传来沙盒("沙盒 (电脑安全)")脚本的方法，以避开浏览器的同源策略。

# OSI七层模型

1.物理层：比特流传输；
2.数据链路层：提供介质访问、链路管理等；
3.网络层：寻址和路由选择；
4.传输层：建立主机端到端连接；
5.会话层：建立、维护和管理会话；
6.表示层：处理数据格式，数据加密等；
7.应用层：提供应用程序间通信；

# TCP/IP四层抽象协议

TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中：
1.应用层：TFTP, HTTP, SNMP, FTP, SMTP, DNS, Telnet等等；
2.传输层：TCP, UDP
3.网络层：IP, ICMP, OSPF, EIGRP, IGMP
4.数据链路层：SLIP, CSLIP, PPP, MTU
每一抽象层建立在低一层提供的服务上，并且为高一层提供服务；

# HTTP、HTTPS（Hyper Text Transfer Protocol）超文本传输协议

- 它是运行在TCP之上的一种应用层协议。
- HTTP是一种无状态协议，即服务器不保留与客户交易时的任何状态。
- HTTP支持持久连接。

## HTTPS 协议提供了三个关键的指标

1. 加密(Encryption)， HTTPS 通过对数据加密来使其免受窃听者对数据的监听，这就意味着当用户在浏览网站时，没有人能够监听他和网站之间的信息交换，或者跟踪用户的活动，访问记录等，从而窃取用户信息。
2. 数据一致性(Data integrity)，数据在传输的过程中不会被窃听者所修改，用户发送的数据会完整的传输到服务端，保证用户发的是什么，服务器接收的就是什么。
3. 身份认证(Authentication)，是指确认对方的真实身份，也就是证明你是你（可以比作人脸识别），它可以防止中间人攻击并建立用户信任。

# DNS（Domain Name System）域名系统

- 是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。
- 一般来说像我们访问的地址都叫做域名，而众所周知网络中的任何一个主机都是IP地址来标识的，也就是说只有知道了这个站点的IP地址才能够成功实现访问操作，不过由于IP地址信息不太好记忆，所以网络中出现了域名这个名字，在访问时我们只需要输入这个好记忆的域名即可，网络中会存在着自动将相应的域名解析成IP地址的服务器，这就是DNS服务器。

# JWT

Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。

最常见的应用场景是：

- 微服务框架下，多种语言服务之间的高效交互。
- 将手机服务、浏览器连接至后台
- 产生高效的客户端库

# 网络安全

攻击、DDOS攻击、网站数据库注入

## DDOS攻击（DDoS:Distributed Denial of Service）分布式拒绝服务

- 利用目标系统网络服务功能缺陷或者直接消耗其系统资源，使得该目标系统无法提供正常的服务。

## CC攻击（Challenge Collapsar）挑战黑洞

- CC攻击的原理是通过代理服务器或者大量肉鸡模拟多个用户访问目标网站的动态页面，制造大量的后台数据库查询动作，消耗目标CPU资源，造成拒绝服务。

## DDoS和CC的区别

- DDoS攻击打的是网站的服务器，而CC攻击是针对网站的页面攻击的。一个是WEB网络层拒绝服务攻击（DDoS），一个是WEB应用层拒绝服务攻击（CC）
- 网络层就是利用肉鸡的流量去攻击目标网站的服务器，针对比较本源的东西去攻击，服务器瘫痪了，那么运行在服务器上的网站肯定也不能正常访问了。而应用层就是我们用户看得到的东西，就比如说网页，CC攻击就是针对网页来攻击的，CC攻击本身是正常请求，网站动态页面的正常请求也会和数据库进行交互的，当这种"正常请求"达到一种程度的时候，服务器就会响应不过来，从而崩溃。
- DDoS是针对IP的攻击，而CC攻击的是服务器资源

# 网络编程（Socket/TCP、UDP/HTTP、RPC）

## Socket（套接字）

- 在计算机通信领域，它是计算机之间通信的一种约定或一种方式。通过socket这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据；
- Socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open --> 读写write/read --> 关闭close”模式来操作。即socket是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO，打开，关闭）。Socket（）函数返回一个整型的Socket描述符，随后的连接建立、数据传输等操作都是通过该Socket实现的。

## Socket怎么通信

如何利用三元组（IP地址、协议、端口）实现网络通信，Socket就是利用三元组解决网络通信的一个中间件工具，就目前而言，几乎所有的应用程序都是采用Socket。
Socket通信的数据传输方式，常用的有两种：
1.SOCK_STREAM：表示面向连接的数据传输方式。数据可以准确无误的到达另一台计算机，如果损坏或者丢失，可以重新发送，但效率相对比较慢。常见的http协议就是使用SOCK_STREAM传输数据，因为要确保数据的正确性，否则网页不能正常解析；
2.SOCK_DGRAM：表示无连接的数据传输方式。计算机只管传输数据，不做数据校验，如果数据在传输中损坏、或者没有到达另一台计算机，是没办法补救的。也就是说，错了就是错了，无法重传。因为SOCK_DGRAM所做的校验工作少，所以效率比SOCK_STREAM高；

## HTTP

HTTP客户端状态码含义：
400 bad request，请求报文存在语法错误
401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
403 forbidden，表示对请求资源的访问被服务器拒绝
404 not found，表示在服务器上没有找到请求的资源

HTTP：keep-alive
client发出的HTTP请求头需要增加Connection:keep-alive字段
Web-Server端要能识别Connection:keep-alive字段，并且在http的response里指定Connection:keep-alive字段，告诉client，我能提供keep-alive服务，并且"应允"client我暂时不会关闭socket连接

http能不能一次连接多次请求，不等后端返回
http本质上是用socket连接，因此发送请求，接写入tcp缓冲，是可以多次进行的，这也是http是无状态的原因；
HTTP无状态协议，是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传；
但为了为支持客户端与服务器之间的交互，我们就需要通过不同的技术为交互存储状态，而这些不同的技术就是Cookie和Session了。

## TCP协议

Transmission Control Protocol （传输控制协议）是一种面向连接（连接导向）的、可靠的、基于IP的传输协议。
通过排序（保证数据的读取是按照正确的格式进行）和重传（保证数据能准确传输到目的地）来确保数据传输的可靠性（即数据的准确传输以及完整性）；
握手详解：<https://blog.csdn.net/Jalon2015/article/details/115219026>
Time Wait的做用：
防止上一次连接中的分段延迟到达后影响新连接，TIME_WAIT状态持续2MSL后，原连接的数据包都已经在网络上消失，不会再干扰新连接。
链接：<https://blog.csdn.net/iCode_girl/article/details/108595066>

## TCP/IP协议

- TCP/IP（TCP（传输控制协议）和IP（网际协议））提供点对点的链接机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。
- 它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，被分别归属到这四个层次结构之中，常被视为简化的七层OSI模型。
- TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据传输前要建立连接，传输完毕后还要断开连接，客户端在收发数据前要使用 connect（）函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据传输开辟通道。

TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话：

1. Shake 1 ：套接字A：“你好，套接字B，我这边有数据要传给你，建立连接吧。”
2. Shake 2 ：套接字B：“你好，我这边已经准备就绪。”
3. Shake 3 ：套接字A：“谢谢你受理我的请求。”

TCP四次握手断开连接，建立连接是数据正确传递的前提，断开连接同样重要，它能让计算机释放不再使用的资源。断开连接可以形象如下比喻：

1. Shake 1 ：套接字A：“任务处理完毕，我希望断开连接。”
2. Shake 2 ：套接字B：“哦，是吗？请稍等，我准备一下。”
3. Shack 3 ：套接字B：“我准备好了，可以断开连接了。”
4. Shake 4 ：套接字A：“好的，谢谢合作。”
TIME_WAIT状态：
如何优雅的断开连接：
TCP的粘包问题以及数据的无边界性：
TCP数据报结构



6、Socket常用函数接口及其原理：
Server：
1.socket（）：创建Socket；
2.Bind（）：绑定socket和端口号；
3.Listen（）：监听端口号；
4.Accept（）：接收来自客户端的连接请求；
5.Recv（）：从socket中读取字符；
6.close（）：关闭socket；
Client：
1.Socket（）：创建socket；
2.Connect（）：连接指定计算机的端口；
3.Send（）：向socket中写入信息；
4.Close（）：关闭socket；

Socket缓冲区以及阻塞模式：
Socket整文参考链接：<https://www.jianshu.com/p/066d99da7cbd>

## RPC

进程间通信（IPC）：
进程间通信是多任务操作系统或联网的计算机之间运行的程序所用的通信技术。
进程间通信技术有两种类型：
1.本地过程调用（LPC）：LPC用在多任务操作系统中，使得同时运行的任务能互相会话。这些任务共享内存使任务同步或者互发信息；
2.远程过程调用（RPC）：RPC类似于LPC，只是在网上工作；
通过LPC或者RPC，程序能利用其它程序或计算机处理的进程；
远程过程调用（RPC）跨越了开放系统互连（OSI）网络通信模型中的传输层和应用层。远程过程调用使得开发应用程序更容易。
客户端/服务器通信的替代方法包括信息队列和IBM的高级程序间通信（APPC）。
RPC在分布式系统中的系统环境建设和应用程序设计中的应用包括：
1.分布式操作系统的进程间通讯；
2.构造分布式计算的软件环境；
3.远程数据库服务（用户在客户端使用RPC模式调用存储过程）；

## 如何实现一个RPC框架

消息队列的设计实际上和 RPC 框架/非常类似
一般情况下， RPC 框架不仅要提供服务发现功能，还要提供负载均衡、容错等功能，这样的 RPC 框架才算真正合格的。

从上图我们可以看出：服务提供端 Server 向注册中心注册服务，服务消费者 Client 通过注册中心拿到服务相关信息，然后再通过网络请求服务提供端 Server。
1.注册中心：Zookeeper（推荐）、Nacos、Redis、ETCD；
ZooKeeper 为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。并且，ZooKeeper 将数据保存在内存中，性能是非常棒的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景）。
2、网络传输：使用 Socket （但是，Socket 是阻塞 IO、性能低并且功能单一）；
3、序列化和反序列化：
(1)因为网络传输的数据必须是二进制；
(2)不仅网络传输的时候需要用到序列化和反序列化，将对象存储到文件、数据库等场景都需要用到序列化和反序列化。
总结：
1、生产者端流程：
(1)加载服务接口，并缓存；
(2)服务注册，将服务接口以及服务主机信息写入注册中心（本例使用的是 ZooKeeper)；
(3)启动网络服务器并监听；
(4)反射，本地调用；
2、消费者端流程：
(1)代理服务接口生成代理对象；
(2)服务发现（连接 ZooKeeper，拿到服务地址列表，通过客户端负载策略获取合适的服务地址）；
(3)远程方法调用（本例通过 Netty，发送消息，并获取响应结果）；

## gRPC

gRPC （gRPC Remote Procedure Calls） 是Google发起的一个开源远程过程调用(Remote procedure call) 系统。该系统基于 HTTP/2协议传输，使用Protocol Buffers作为接口描述语言。
gRPC是由 google开发的一个高性能、通用的开源RPC框架，主要面向移动应用开发且基于HTTP/2协议标准而设计，同时支持大多数流行的编程语言。
gRPC基于 HTTP/2协议传输，而HTTP/2相比HTTP1.x有以下一些优势：
1、用于数据传输的二进制分帧；
2、多路复用（HTTP/2支持通过同一个连接发送多个并发的请求）；
3、服务端推送（在HTTP/2中，服务器可以对客户端的一个请求发送多个响应）；
4、减少网络流量的头部压缩；
同时gRPC使用Protocol Buffers作为序列化协议。它是一种与语言、平台无关 、可扩展的序列化结构数据。它的定位类似于JSON、XML，但是比他们更小、更快、更简单。
gRPC 是如何进行远程调用的？
golang中使用grpc服务：<https://blog.csdn.net/SHELLCODE_8BIT/article/details/122987268>

## RPC和Socket的区别

1. RPC（Remote Procedure Call，远程过程调用）是建立在Socket之上的，它比socket需要更多的网络和系统资源。出于一种类比的愿望，在一台机器上运行的主程序，可以调用另一台机器上准备好的子程序，就像LPC（本地过程调用）。
2. 越底层，代码越复杂、灵活性越高、效率越高；越上层，抽象封装的越好、代码越简单、效率越差。Socket和RPC的区别再次说明了这点。
3. RPC方法的基本原则是－－以模块调用的简单性忽略通讯的具体细节，以便程序员不用关心C/S之间的通讯协议，集中精力对付实现过程。这就决定了 RPC生成的通讯包不可能对每种应用都有最恰当的处理办法，与Socket方法相比，传输相同的有效数据，RPC占用更多的网络带宽。
RPC是在Socket的基础上实现的，另外，在对程序优化时，程序员虽然可以直接修改由rpcgen产生的
类比
两个老板手下各有一个负责接通MSN的秘书。这两个秘书就是基于RPC协议建立的会话层通信。老本不需要知道怎么使用MSN，只要告诉秘书，秘书就会通过MSN与对方建立会话请求和响应。而基于Socket的通信，老板需要会使用MSN，这样尽管老板需要事先培训一下MSN的简单使用常识，但若与对方通信时，无需经过秘书，效率更高。

# 网络中进程的通信方式

Socket主要是用来解决网络通信的，那网络中的进程是如何通信的呢？

## 本地进程间通信

1. 消息队列（管道、消息队列、FIFO）；
2. 同步（互斥量、条件变量、读写锁、文件和写记录、信号量）；
3. 共享内存（匿名的和具名的，eg：channel）；
4. 远程过程调用（RPC）；

## 网络中如何通信

两个待解决问题：1、如何标识一台主机；2、如何标识唯一进程，本地通过pid，网络中如何标识；
解决办法：
1.TCP/IP协议可以通过网络层的“IP地址”唯一标识网络中的主机；
2.传输层的“协议+端口”可以唯一标识主机中的应用程序（进程），因此，利用三元组（IP地址，协议，端口）就可以标识网络中的进程，网络中的进程通信就是利用这个标志与其它进程交互；
