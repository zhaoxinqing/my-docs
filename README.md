# Technical Documentation

[toc]

## 第一章 操作系统-Linux

### 学习Linux的三步走

1. 了解 Linux 的基本概念，会敲常用命令来应对工作。从事开发和运维岗位的同学。
2. 能理解 Linux 尤其是其内核的设计思想，能将其思想应用到系统的架构设计中。冲击大厂、做架构师、从事底层开发。
3. 熟知 Linux 的使用、思想和细节，更能推陈出新，自主创造新的系统。

> 操作系统：<https://xiaolincoding.com/os>
> 牛客网Linux专项练习：<https://www.nowcoder.com/exam/intelligent>
> Linux自学资源：<https://github.com/0voice/linux_kernel_wiki>
> Linux 常用命令：<https://www.runoob.com/linux/linux-command-manual.html>

### Docker

……

### Kubernates

k8s全称kubernetes，是源于谷歌内部的大规模集群管理系统Borg，面向应用的容器集群部署和管理的系统；一个K8S系统，通常称为一个K8S集群（Cluster）。这个集群主要包括两个部分：一个Master节点（主节点）和一群Node节点（计算节点）。

数据结构、算法：
算法思想：
动态规划：把复杂的问题分阶段进行简化，逐步简化成简单的问题。动态规划中包含三个重要的概念，最优子结构、边界、状态转移公式。
贪心算法：
排序算法：
查找算法：
排序算法：
分治算法：
深度优先、广度优先：
<https://blog.csdn.net/qq_33204444/article/details/79202347>
<https://blog.csdn.net/qq_33204444/article/details/79192626>
一致性hash和hash槽：
一致性hash，：
在解决分布式系统中负载均衡的问题时候可以使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡的作用。但是普通的余数hash（hash(比如用户id)%服务器机器数）算法伸缩性很差，当新增或者下线服务器机器时候，用户id与服务器的映射关系会大量失效。
一致性hash则利用hash环（一个0-2^32的闭合圆）对其进行了改进，防止雪崩的发生。
虚拟节点：当服务器节点比较少的时候会出现上节所说的一致性hash倾斜的问题，一个解决方法是多加机器，但是加机器是有成本的，那么就加虚拟节点。
首先把服务器的多个ip映射到了一致性hash环上，然后根据hash值在hash环上的位置顺时针找距离最近的ip作为路由ip。当一个ip处理的一部分用户的映射关系被破坏了，则负责处理的请求被顺时针下一个节点委托处理，避免了余数hash中一个服务器下线，用户id与服务器的映射关系会大量失效的情况。
hash槽：
一致性hash如果删除节点或者一个节点失效，其负载会全落在下一个节点，如果下一个节点撑不起这种负载，则可能会形成节点的循环雪崩；节点太少的话又容易产生数据倾斜，添加节点会导致一部分负载的重新节点迁移；
rediscluster采用数据分片的哈希槽来进行数据存储和数据的读取。rediscluster一共有2^14（16384）个槽，所有的master节点都会有一个槽区比如0～1000，槽数是可以迁移的。master节点的slave节点不分配槽，只拥有读权限。但是注意在代码中rediscluster执行读写操作的都是master节点，并不是你想的读是从节点，写是主节点。第一次新建rediscluster时，16384个槽是被master节点均匀分布的。
一致性哈希是创建虚拟节点来实现节点宕机后的数据转移并保证数据的安全性和集群的可用性的。rediscluster是采用master节点有多个slave节点机制来保证数据的完整性的,master节点写入数据，slave节点同步数据。当master节点挂机后，slave节点会通过选举机制选举出一个节点变成master节点，实现高可用。但是这里有一点需要考虑，如果master节点存在热点缓存，某一个时刻某个key的访问急剧增高，这时该mater节点可能操劳过度而死，随后从节点选举为主节点后，同样宕机，一次类推，造成缓存雪崩。
和一致性哈希相比，哈希槽不是闭合的，key的定位规则是根据CRC-16(key)%16384的值来判断属于哪个槽区，从而判断该key属于哪个节点，而一致性哈希是根据hash(key)的值来顺时针找第一个hash(ip)的节点，从而确定key存储在哪个节点。
复杂度分析：

负载均衡：
负载共享，是指对系统中的负载情况进行动态调整，以尽量消除或减少系统中各节点负载不均衡的现象。
具体实现方法是将过载节点上的任务转移到其他轻载节点上，尽可能实现系统各节点的负载平衡，从而提高系统的吞吐量。
负载共享有利于统筹管理分布式系统中的各种资源，便于利用共享信息及其服务机制扩大系统的处理能力。
动态负载共享策略是指把系统中各节点上已有的负载作为参考信息，在运行过程中，根据系统中各节点的负载状况，随时调整负载的分配，使各节点尽可能保持负载的平衡。

后端框架：
Web应用程序是一个各种编程语言一个非常流行的应用领域；它的后台开发涉及到的知识有：
模型设计：关系型数据库模型设计
SQL、ORM
Restful API设计
MVC框架：
MVC是模型(model)－视图(view)－控制器(controller)的缩写，是一种软件设计典范，它用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。
Model（模型）是应用程序中用于处理应用程序数据逻辑的部分，通常模型对象负责在数据库中存取数据。
View（视图）是应用程序中处理数据显示的部分，通常视图是依据模型数据创建的。
Controller（控制器）是应用程序中处理用户交互的部分，通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。
MVC分层有助于管理复杂的应用程序，并简化了分组开发；
框架和设计模式：
框架：（MVC、ORM…）：通常是代码重用，来对软件设计进行分工，是大智慧；
设计模式：比框架更抽象，是对具体问题提出解决方案，以提高代码复用率，降低耦合度，是小技巧；

API网关：就像一个反向代理，它将获取客户端请求并重定向，很好的解决了微服务调用、统一接入等问题；并通过暴漏一个公开的IP，保护内部的所有的私有的IP地址（后端的微服务），从而增强系统的安全性；在微服务中网关具备的功能：身份验证和鉴权；服务发现；重试策略/断路器；限流；负载均衡；日志/追踪查询信息；IP白/黑名单
Nginx：是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；可以作为一个HTTP服务器进行网站的发布处理，还可以作为反向代理进行负载均衡的实现。Nginx使用基于事件驱动架构，使得其可以支持数以百万级别的TCP连接。高度的模块化和自由软件许可证使得第三方模块层出不穷（这是个开源的时代啊~）。Nginx是一个跨平台服务器，可以运行在Linux，Windows，FreeBSD，Solaris，AIX，Mac OS等操作系统上。

RESTful API：REST架构是针对Web应用而设计的，其目的是为了降低开发的复杂性，提高系统的可伸缩性。REST的架构设计：（Representational State Transfer）名词解释：representation state transfer（表现层状态转化）；Resource:资源，即数据，存在互联网上的可被访问的实体；Representation：数据的某种表现形式，如HTML,JSON。State Transfer：状态变化，HTTP方法实现。
常用设计模式：
单库单应用模式：最简单的，可能大家都见过
内容分发模式：目前用的比较多
查询分离模式：对于大并发的查询、业务
微服务模式：适用于复杂的业务模式的拆解
多级缓存模式：可以把缓存玩的很好
分库分表模式：解决单机数据库瓶颈
弹性伸缩模式：解决波峰波谷业务流量不均匀的方法之一
多机房模式：解决高可用、高性能的一种方法
池子的设计：内存池、进程池、线程池
池的概念：服务器的硬件资源“充裕”，那提高服务器性能的一个很直接的方法就是以空间换时间，即“浪费”服务器的硬件资源，以换取其运行效率。
池是一组资源的集合，这组资源在服务器启动之初就完全被创建并初始化，这称为静态资源分配。当服务器进入正式运行阶段，即开始处理客户请求的时候，如果它需要相关的资源，就可以直接从池中获取，无需动态分配。
直接从池中取得所需资源比动态分配资源的速度要快得多，因为分配系统资源的系统调用都是很耗时的。当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用来释放资源。从最终效果来看，池相当于服务器管理系统资源的应用设施，它避免了服务器对内核的频繁访问。
内存池：
内存池是一种内存分配方式。直接使用new、malloc等系统调用申请分配内存，由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。
内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存，使得内存分配效率得到提升。
从内存池可分配内存单元大小来分，可以分为固定内存池和可变内存池。所谓固定内存池是指应用程序每次从内存池中分配出来的内存单元大小事先已经确定，是固定不变的；而可变内存池则每次分配的内存单元大小可以按需变化，应用范围更广，而性能比固定内存池要低。
进程池和线程池
从线程安全的角度来分，内存池可以分为单线程内存池和多线程内存池。进程池和线程池相似，对进程池的描述也适用于线程池
进程池是由服务器预先创建的一组子进程，这些子进程的数目在3~10个之间（当然这只是典型情况）。线程池中的线程数量应该和CPU数量差不多。进程池中的所有子进程都运行着相同的代码，并具有相同的属性，比如优先级、PGID等。当有新的任务来到时，主进程将通过某种方式选择进程池中的某一个子进程来为之服务。相比于动态创建子进程，选择一个已经存在的子进程的代价显得小得多。至于主进程选择哪个子进程来为新任务服务，则有两种方法：
主进程使用某种算法来主动选择子进程。最简单、最常用的算法是随机算法和Round Robin（轮流算法）。
主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上。当有新的任务到来时，主进程将任务添加到工作队列中。这将唤醒正在等待任务的子进程，不过只有一个子进程将获得新任务的“接管权”，它可以从工作队列中取出任务并执行之，而其他子进程将继续睡眠在工作队列上。
当选择好子进程后，主进程还需要使用某种通知机制来告诉目标子进程有新任务需要处理，并传递必要的数据。最简单的方式是，在父进程和子进程之间预先建立好一条管道，然后通过管道来实现所有的进程间通信。在父线程和子线程之间传递数据就要简单得多，因为我们可以把这些数据定义为全局，那么它们本身就是被所有线程共享的。
线程池主要用于：
需要大量的线程来完成任务，且完成任务的时间比较短（WEB服务器完成网页请求这样的任务，单个任务小，而任务数量巨大），但对于长时间的任务（比如一个Telnet连接请求，因为Telnet会话时间比线程的创建时间大多了）线程池的优点就不明显了。
对性能要求苛刻的应用，比如要求服务器迅速响应客户请求。
接受突发性的大量请求，但不至于使服务器因此产生大量线程的应用。
生产者消费者模型：
属于面向过程的编程模型，该模式还需要有一个缓冲区处于生产者和消费者之间，作为一个中介。
生产者把数据放入缓冲区，而消费者从缓冲区取出数据（避免直接依赖，降低耦合，异步防止阻塞），生产者与消费者模式是通过一个容器来解决生产者与消费者的强耦合关系，
生产者与消费者之间不直接进行通讯，而是利用阻塞队列来进行通讯，生产者生成数据后直接丢给阻塞队列，消费者需要数据则从阻塞队列获取，
实际应用中，生产者与消费者模式则主要解决生产者与消费者生产与消费的速率不一致的问题，达到平衡生产者与消费者的处理能力，而阻塞队列则相当于缓冲区。
还有一个比较典型的例子便是日志的记录，多线程产生日志，但写日志由于文件独占，不能多线程来写，于是我们就可以把线程压入队列，由日志线程来读取队列数据，完成写日志的操作。
添加中间件：
什么是中间件：是基础软件的一大类，属于可复用软件的范畴。中间件处于操作系统软件与用户的应用软件的中间。中间件在操作系统、网络和数据库之上，应用软件的下层，总的作用是为处于自己上层的应用软件提供运行与开发的环境，帮助用户灵活、高效地开发和集成复杂的应用软件；IDC的定义是：中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，管理计算资源和网络通信。
中间件解决的问题是：在中间件产生以前，应用软件直接使用操作系统、网络协议和数据库等开发，这些都是计算机最底层的东西，越底层越复杂，开发者不得不面临许多很棘手的问题，如操作系统的多样性，繁杂的网络程序设计、管理，复杂多变的网络环境，数据分散处理带来的不一致性问题、性能和效率、安全，等等。这些与用户的业务没有直接关系，但又必须解决，耗费了大量有限的时间和精力。于是，有人提出能不能将应用软件所要面临的共性问题进行提炼、抽象，在操作系统之上再形成一个可复用的部分，供成千上万的应用软件重复使用。这一技术思想最终构成了中间件这类的软件。中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性。

新名词和技术：
DPI：一种基于应用层的流量检测和控制技术，称为“深度包检测”，还可以通过设置不懂的权重，来分离各种数据包，从而更高效的应用有限的网络宽带资源，具有管理网络性能的用处。
架构和部署
分布式系统
建立在网络之上的软件系统
链接：<https://baike.baidu.com/item/分布式系统/4905336>
分布式相关知识点：<https://zhuanlan.zhihu.com/p/140272240>
分布式计算：hadoop、HBase
现在普遍认为整个Apache Hadoop“平台”包括Hadoop内核、MapReduce、Hadoop分布式文件系统（HDFS）以及一些相关项目，有Apache Hive和Apache HBase等等；
主要子项目
Hadoop Common：在0.20及以前的版本中，包含HDFS、MapReduce和其他项目公共内容，从0.21开始HDFS和MapReduce被分离为独立的子项目，其余内容为Hadoop Common
HDFS：Hadoop分布式文件系统（Distributed File System）－HDFS（Hadoop Distributed File System）
MapReduce：并行计算框架，0.20前使用org.apache.hadoop.mapreduce旧接口，0.20版本开始引入org.apache.hadoop.mapreduce的新API
相关项目
Apache HBase：分布式NoSQL列数据库，类似谷歌公司BigTable。
Apache Hive：构建于hadoop之上的数据仓库，通过一种类SQL语言HiveQL为用户提供数据的归纳、查询和分析等功能。Hive最初由Facebook贡献。
Apache Mahout：机器学习算法软件包。
Apache Sqoop：结构化数据（如关系数据库）与Apache Hadoop之间的数据转换工具。
Apache ZooKeeper：分布式锁设施，提供类似Google Chubby的功能，由Facebook贡献。
Apache Avro：新的数据序列化格式与传输工具，将逐步取代Hadoop原有的IPC机制。
维基百科：<https://zh.wikipedia.org/zh-cn/Apache_Hadoop>
消息队列
解决的问题：解耦、异步、削峰
架构中引入MQ后存在的问题：
降低系统可用性。如果MQ挂掉，导致整个系统崩溃；
系统复杂性变高。可能发重复消息，导致插入重复数据；消息丢了；消息顺序乱了；系统B,C,D挂了，导致MQ消息积累，磁盘满了；
一致性问题。本来应该A,B,C,D都执行成功了再返回，结果A,B,C执行成功D失败。
建议：中小型公司RabbitMQ，大公司：RocketMQ，大数据实时计算：Kafka。
解决方案：
事务机制：（一般不采用，同步的，生产者发送消息会同步阻塞卡住等待你是成功还是失败。会导致生产者发送消息的吞吐量降下来）；
持久化到磁盘；
面试题：<https://wenku.baidu.com/view/36c47b5a32b765ce0508763231126edb6f1a76a9.html>
链接：<https://zhuanlan.zhihu.com/p/356235333>
Go语言系列之RabbitMQ消息队列：<https://blog.51cto.com/u_13919520/3153035>
消息队列对比详解：<https://baijiahao.baidu.com/s?id=1708572554459077699&wfr=spider&for=pc>
系统设计面试题：如何实现一个RPC框架
链接：<https://xiaozhuanlan.com/topic/8472610953>
分布式系统、微服务
微服务是架构设计方式，分布式是系统部署方式，两者概念不同
ESB（企业服务总线）、微服务API网关
简单来说ESB就是一根管道，用来连接各个服务节点。为了集成不同系统，不同协议的服务，ESB做了消息的转化解释和路由工作，让不同的服务互联互通；
API网关是一个服务器，是系统的唯一入口。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。
链接：<https://www.cnblogs.com/xuwc/p/13989081.html>
SOA架构（Service Oriented Architecture）
面向服务的架构。它是一种设计方法，其中包含多个服务，服务之间通过相互依赖最终提供一系列的功能。
IOT（Internet of Things）物联网平台/应用
安全性是物联网首要考虑的问题；
网络通信协议和Web：
Web（WorldWideWeb）全球广域网，是一种基于超文本HTML和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。建立在Internet上的一种网络服务
http三个版本区别：
1.0短链接（100张图，100次tcp握手和挥手）
1.1长连接（100张图，1次tcp握手挥手）
2.0长连接+多路复用模型（五大模型之一）
DNS：域名服务器（DomainNameServer）提供域名解析的服务，实现域名到ip地址之间的转化，网络之间是通过ip连接的，域名只是为了方便记忆；
路由：连接多个网络或网段的网络设备，它能将不同网络或网段之间的数据信息进行“翻译”，以使它们能够相互“读”懂对方的数据，从而构成一个更大的网络。
Web响应状态码：是服务端对客户端请求的一种状态响应，不同的状态码代表着服务端对请求的不同响应结果。
网络常见缩写##
LAN：局部区域网，局域网，本地网（全写为localareanetwork）;
DHCP：（动态主机配置协议）是一个局域网的网络协议。
VPN：（虚拟专用网络）通过一个公用互联网络建立的一个临时、安全、稳定隧道，使用这条隧道可以对数据进行几倍加密，主要使用在企业办公当中。
ICMP：（因特网控制报文协议）TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。这些控制消息不传输用户数据，但是对于用户数据的传递起着重要的作用。ICMP报文有两种：差错报告报文和询问报文；
RPC：（远程过程调用协议）是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式、多程序在内的应用程序更加容易。
ARP（Address Resolution Protocol)（地址解析协议）提供了网络层地址（IP地址）到物理地址（mac地址）之间的动态映射。网络层以上的协议用IP地址来标识网络接口，但以太数据帧传输时，以物理地址来标识网络接口，因此我们需要进行IP地址与物理地址之间的转化。
API：（应用编程接口）是一些预先定义的函数，或指软件系统不同组成部分，衔接的约定。目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节。
ORM：（对象关系映射）用于实现面向对象编程语言里不同类型系统的数据之间的转换的一种程序技术。ORM提供了对数据库的映射，不用sql直接编码，能够像操作对象一样从数据库获取数据。提高了开发效率。ORM可以自动对实体对象与数据库中的表进行字段与属性的映射，所以我们实际可能已经不需要一个专用的、庞大的数据访问层。
对websocket协议的认识。
是HTML5开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。
Socket是TCP层的封装，浏览器和服务器只需要做一个握手的动作就可以实现数据的相互传送；
Header很小，信息传输效率高；服务器可以主动推送数据到浏览器；
socket长连接：指的是客户端和服务端之间保持一个socket连接长时间不断开，保持连接的情况下可以节省系统资源；
网络延时、完整性约束
时延：是指一个报文或分组从一个网络（或一条链路）的一端传送到另一端所需的时间；
数据完整性约束：为了防止不符合规范的数据进入数据库，在用户对数据进行插入、修改、删除等操作时，DBMS自动按照一定的约束条件对数据进行监测，使不符合规范的数据不能进入数据库，以确保数据库中存储的数据正确、有效、相容；
脏数据：
是指源系统中的数据不在给定的范围内或对于实际业务毫无意义，或是数据格式非法，以及在源系统中存在不规范的编码和含糊的业务逻辑。
在数据库技术中,脏数据产生于临时更新（脏读）。例如：事务A更新了某个数据项X，由于某种原因事务A回滚。但是在回滚之前，另一个事务B读取了数据项X的值，A回滚了事务，数据项恢复了原值。事务B读取的就是数据项X的就是一个“临时”的值，就是脏数据。
《图解TCP/IP》读书笔记：<https://www.cnblogs.com/edisonchou/p/5987827.html>
数据在TCP层称为流（Stream），数据分组称为分段（Segment）。作为比较，数据在IP层称为Datagram，数据分组称为分片（Fragment）。UDP中分组称为Message。
粘包现象值存在于TCP协议，UDP协议不存在粘包的情况
粘包原因：
发送端：连续发送多个小的数据包（就是指字节数小于报文段-MSS的大小），由于Nagle优化算法导致的几个小包合并为一个包。
接收端：一次从自己的缓冲区中能够读取的字节数少于对端发送的一个数据包的字节数，导致本段在读取的时候数据不能一次读取完毕
拆包解决：提前告知数据大小，将数据长度合并到报文中，由程序标识数据流的结束。
广域网（WAN,公网,外网），就是我们通常所说的Internet，它是一个遍及全世界的网络。局域网（LAN,私网,内网），相对于广域网（WAN）而言，主要是指在小范围内的计算机互联网络。这个“小范围”可以是一个家庭，一所学校，一家公司，或者是一个政府部门。BT中常常提到的公网、外网，即广域网（WAN）；BT中常常提到私网、内网，即局域网（LAN）。广域网上的每一台电脑（或其他网络设备）都有一个或多个广域网IP地址（或者说公网、外网IP地址），广域网IP地址一般要到ISP处交费之后才能申请到，广域网IP地址不能重复；局域网（LAN）上的每一台电脑（或其他网络设备）都有一个或多个局域网IP地址（或者说私网、内网IP地址），局域网IP地址是局域网内部分配的，不同局域网的IP地址可以重复，不会相互影响。
路由器和交换机？
交换机工作在OSI的第二层（数据链路层），所以它的工作原理比较简单，而路由器工作在OSI的第三层（网络层），可以得到更多的协议信息，路由器可以做出更加智能的转发决策。
交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用不同网络的ID号（即IP地址）来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络，有时这些第三层的地址也称为协议地址或者网络地址。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。
传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。
路由器提供了防火墙的服务。路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。
CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。
Haproxy是一个使用C语言编写的自由及开放源代码软件，其提供高可用性、负载均衡，以及基于TCP和HTTP的应用程序代理。HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。HAProxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中，同时可以保护你的web服务器不被暴露到网络上。HAProxy实现了一种事件驱动,单一进程模型，此模型支持非常大的并发连接数。多进程或多线程模型受内存限制、系统调度器限制以及无处不在的锁限制，很少能处理数千并发连接。事件驱动模型因为在有更好的资源和时间管理的用户空间(User-Space)实现所有这些任务，所以没有这些问题。此模型的弊端是，在多核系统上，这些程序通常扩展性较差。这就是为什么他们必须进行优化以使每个CPU时间片(Cycle)做更多的工作。
keepalived是一个类似于Layer2,4,7交换机制的软件。是Linux集群管理中保证集群高可用的一个服务软件，其功能是用来防止单点故障。keepalived的工作原理：keepalived是基于VRRP协议实现的保证集群高可用的一个服务软件，主要功能是实现真机的故障隔离和负载均衡器间的失败切换，防止单点故障。在了解keepalived原理之前先了解一下VRRP协议。
VRRP协议：Virtual Route Redundancy Protocol虚拟路由冗余协议。是一种容错协议，保证当主机的下一跳路由出现故障时，由另一台路由器来代替出现故障的路由器进行工作，从而保持网络通信的连续性和可靠性。
单点登录：SSO（Single Sign On），是指在一个多系统共存的环境下，用户在一处登录后，就不用在其它系统中登录，也就是用户的一次登录就能得到其它所有系统的信任；对于大型系统来说使用单点登录可以减少用户很多的麻烦，多台主机负载均衡的话就涉及到session共享的问题，实现单点登录要解决如何产生和存储信任，再就是其它系统如何验证这个信任的有效性，因此要点有两个：存储信任，-验证信任：①以Cookie作为凭借媒介，②通过JSONP实现，③通过页面重定向的方式，④使用独立登录系统；
网络掩码的作用：将某个IP地址划分成网络地址和主机地址两部分

HTTP客户端状态码含义：
400 bad request，请求报文存在语法错误
401 unauthorized，表示发送的请求需要有通过HTTP认证的认证信息
403 forbidden，表示对请求资源的访问被服务器拒绝
404 not found，表示在服务器上没有找到请求的资源
TCP/IP协议
握手详解：<https://blog.csdn.net/Jalon2015/article/details/115219026>
HTTP：keep-alive
client发出的HTTP请求头需要增加Connection:keep-alive字段
Web-Server端要能识别Connection:keep-alive字段，并且在http的response里指定Connection:keep-alive字段，告诉client，我能提供keep-alive服务，并且"应允"client我暂时不会关闭socket连接
http能不能一次连接多次请求，不等后端返回
http本质上市是用socket连接，因此发送请求，接写入tcp缓冲，是可以多次进行的，这也是http是无状态的原因
Time Wait的做用
防止上一次连接中的分段延迟到达后影响新连接
TIME_WAIT状态持续2MSL后，原连接的数据包都已经在网络上消失，不会再干扰新连接。
链接：<https://blog.csdn.net/iCode_girl/article/details/108595066>
Socket：
TCP是面向连接的套接字，而UDP是面向无连接的套接字；
TCP编程的客户端和服务端都是通过Socket来完成的。
tcp与udp区别，udp优点，适用场景
tcp传输的是数据流，而udp是数据包，tcp会进过三次握手，udp不需要
TCP协议
Transmission Control Protocol（传输控制协议）是一种面向连接（连接导向）的、可靠的、基于IP的传输协议。
通过排序（保证数据的读取是按照正确的格式进行）和重传（保证数据能准确传输到目的地）来确保数据传输的可靠性（即数据的准确传输以及完整性）；
集群（技术）：
集群（cluster）技术是一种较新的技术，通过集群技术，可以在付出较低成本的情况下获得在性能、可靠性、灵活性方面的相对较高的收益，其任务调度则是集群系统中的核心技术。
集群是一组相互独立的、通过高速网络互联的计算机，它们构成了一个组，并以单一系统的模式加以管理。一个客户与集群相互作用时，集群像是一个独立的服务器。集群配置是用于提高可用性和可缩放性。
百度百科：<https://baike.baidu.com/item/集群技术/9774443>

工具
git文件版本，使用顺序，merge跟rebase
rebase和merge的区别：<https://blog.csdn.net/weixin_41231928/article/details/107040880>
Git回滚代码到某个commit
2个回退命令即可完成回退到提交的commited节点
Git log：获取历史提交信息；
Git reset--hard commited_id(提交记录的唯一标识id)

## 第二章 语言-Golang

### 1、常见编程语言及应用环境

1.C：操作系统、嵌入式、驱动开发；
2.C++：图形图像、科研、通信、桌面软件、游戏、游戏服务器；
3.C#：Windows桌面软件、.NET Web、服务器
4.Java： Java SE：跨平台的桌面应用，Android；Java EE：企业级应用，web开发、服务器后端；Java ME：手机应用、流行于非智能机时代；Java Android：用于安卓开发应用
5.GO：高性能服务器应用，比较年轻
6.Erlang：高并发服务器应用，多用于游戏
7.Python：Web、科学计算、运维
8.Ruby：web
9.HTML/CSS：标记语言，主要是给前端工程师构建页面使用
10.Python应用领域主要有：自动化运维、人工智能领域、网路爬虫、科学计算
汇编语言：汇编语言（Assembly Language）是任何一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。

### 2、Golang基础

1.make 和 new 的区别
2.数组和切片的区别
3.for range 的时候它的地址变化
4.多个 defer 的执行顺序，defer 在什么时机会修改返回值？
5.uint 类型溢出
6.介绍 rune 类型
7.解析 tag 是怎么实现的？反射原理是什么？
8.调用函数传入结构体时，应该传值还是指针？ （Golang 都是传值）context 结构，使用场景和用途
9.channel底层实现原理，是否线程安全，关闭问题？锁用在什么地方？
10.map主要特性，使用注意的点，删除一个 key时的内存释放
11.Goroutine的并发编程模型基于的GMP模型
12.进程、线程、协程
13.Go 如何实现原子操作？
14.Mutex 是悲观锁还是乐观锁
15.并发控制
16.go gc 是怎么实现的
17.如何优雅的实现一个 goroutine 池（百度、手写代码）：链接：<https://cloud.tencent.com/developer/news/598822>
18.内存相关：内存泄漏及内存泄漏的排查，内存逃逸，内存分配
19.介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？通常小对象过多会导致GC三色法消耗过多的GPU。优化思路是，减少对象分配。
20.go内存管理金字塔结构

### 3、网络编程

## 第三章 数据库-MySQL

1、事务、事务隔离级别
2、索引：主键索引和唯一索引
3、Mysql B+树
4、两种引擎：MyISAM、InnoDB
5、数据库设计三范式
6、SQL优化策略：<https://www.51cto.com/article/623584.html>
7、SQL注入问题
8、多版本并发控制
9、聚簇索引、非聚簇索引

### 1、数据库设计及优化

优秀的数据库设计，可以减少数据冗余、避免数据维护异常、节约空间、高效访问。
步骤：
需求分析：分析数据属性和特点
逻辑设计：使用ER图【实体-联系图(Entity Relationship Diagram)】对数据库进行逻辑建模
物理设计：根据数据库自身的特点 将逻辑设计转化为物理设计
维护优化：新的需求进行建表、索引优化、大表拆分
详细：<https://www.jianshu.com/p/23a36a453b56>

### 2、数据库查询整体优化思路

为什么优化：随着程序的使用和业务的拓展，导致数据量越来越大，数据库处理压力增大、吞吐量出现瓶颈；
优化的思路：
1. 表字段在设计阶段，通过需求分析及逻辑设计阶段，使用ER图【实体-联系图(Entity Relationship Diagram)】对数据库进行逻辑建模，并根据数据库自身的特点，将逻辑设计转化为物理设计，采用更优的表、字段的存储方案；
2. 采用数据库自身提供的优化方案，如创建更适合业务需求的索引；
3. 查询缓存、热点、稳定数据缓存；
4. 横向扩展、主从复制、读写分离等方式，实现高性能和高可用；
5. 查询逻辑及语句优化，根据查询日志，定位查询效率较低的SQL，针对性做优化；
EXPLAIN命令是查看优化器如何决定执行查询的主要方法，我们可一利用这个来优化我们的sql和添加索引。
链接：<https://blog.csdn.net/qq_36622496/article/details/90638765>

## 第四章 缓存-Redis

1.Redis基本概念；
2.Redis基本数据结构与常用指令；
3.Redis；
4.Redis八种淘汰策略与三种删除策略；
5.Redis三种持久化机制；
6.Redis事务机制；
7.Redis内存模型及内存划分；
8.Redis虚拟内存；
9.Redis客户端通信RESP协议；
10.Redis高可用机制：主从复制、哨兵、代理式/分片式集群；
> Redis面试宝典：<https://baijiahao.baidu.com/s>
> 数据结构和命令：<https://blog.csdn.net/m0_64830623/article/details/123145942>
> Redis五大数据类型及使用场景：<https://baijiahao.baidu.com/s?id=1682379171066196544&wfr=spider&for=pc>
> Redis核心底层协议-RESP：<https://baijiahao.baidu.com/s?id=1669496265525774478&wfr=spider&for=pc>
> 网址：<https://xiaolincoding.com/redis/>
1、缓存：
1.提高系统的性能，尽量减少IO的操作，特别是磁盘IO的操作；
2.使用缓存技术来提高系统的性能，并且降低数据库的负载。缓存就是通过在本地磁盘内保存的资源副本，减少对源服务器的访问，节省通信流量和通信时间，提高系响应速度和用户体验；
数据一致性问题：
串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低；
把一些列的操作都放到队列里面，顺序肯定不会乱，但是并发高了，这队列很容易阻塞，反而会成为整个系统的弱点，瓶颈；
最经典的KV、DB读写模式：CacheAsidePattern
读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。更新的时候，先更新数据库，然后再删除缓存。
缓存和数据库数据不一致，
加入了缓存之后，主从不一致的时间被拉长；
在从库有数据更新之后，将缓存当中的数据也同时进行更新，即当从库发生了数据更新之后，向缓存发出删除，淘汰这段时间写入的旧数据。
如果服务对耗时不是特别敏感可以增加重试；
如果服务对耗时敏感可以通过异步补偿任务来处理失败的更新，或者短期的数据不一致不会影响业务，那么只要下次更新时可以成功，能保证最终一致性就可以。
2、消息队列：
1.使用消息队列的目的：解耦，异步，削峰：
2.在高并发分布式环境下，由于来不及同步处理，通过使用消息队列，我们可以异步处理请求，从而缓解系统的压力。
使用消息队列会：
1.降低系统可用性：本来系统正常，加入消息队列，万一消息队列挂了，整个系统可能都会受牵连，因此，系统可用性会降低
2.增加系统复杂性：加入了消息队列，要多考虑，一致性问题、消息不被重复消费问题、保证消息可靠性传输，顺序消费等问题，考虑的东西更多，系统复杂性更大。
技术选型：RocketMQ（功能完备，扩展性佳）和kafka（多用于大数据领域）分布式架构（高可用）；

2、缓存与DB数据一致性问题
1、读写分离：读请求只访问缓存，写请求只修改数据库和缓存。写请求修改数据库和缓存是事务性动作，如果更新数据库成功，更新缓存失败，则回滚数据库，保证缓存与数据库数据的强一致。这样实现了读写分离，不仅提高了读的响应速度，由写请求负责缓存与数据库一致，只有写请求成功才会影响到缓存的内容，时效性大大增强。
2、缓存队列：沿用场景一的解决方案，为解决其缺陷，添加队列，凡是遇到写请求，则将写请求放入队列中，由队列对写请求统一管理，写请求处理成功，则从队列中删除。当有一个读请求过来时，到队列查询，是否有对应的写请求，如果有则放入队列中，等待写请求执行完之后再执行读请求。为防止某个请求阻塞情况，为其设置超时机制或者过期机制。
3、读写分离缓存队列：访问量大，处理器来不及处理，队列内的请求数量越来越高，则会影响查询效率。解决：分布式数据库集群，再加上消息队列 （kafka等等）

## 第五章 网络基础

1、常用端口号：Redis（6379）、MySQL（3306）、PostgreSQL（5432）、HTTP（80）、HTTPS（443）
2、REST，RESTFUL及特点
3、常用状态码
4、TCP三次握手与四次挥手
5、远程调用：RPC
6、HTTP 2.0特性
7、Websocket特点
8、HTTP和HTTPS
9、TCP、UDP
10、网际控制报文协议ICMP，
11、OSI七层、TCP/IP四层
12、IP地址分类和基本特点
13、域名解析(DNS解析)
14、数据链路层的作用
> 网络基础知识学习网址：<https://xiaolincoding.com/network/>

### 1、网络硬件设备

中继器：中继器从一个网络电缆里接收信号， 放大它们，将其送入下一个电缆。
集线器：相当于多接口中继器，可将各节点连接成一个局域网，但任何时刻都只能有一个节点通过公共信道发送数据。逻辑上仍然是一个总线网，使用CSMA/CD协议。不能隔离碰撞域。不能连接不同技术和速率的网络。
网桥：相比较而言，网桥对从关卡上传下来的信息更敏锐一些。网桥是一种对帧进行转发的技术，根据MAC分区块，可隔离碰撞。网桥将网络的多个网段在数据链路层连接起来。
交换机：用于电光信号转发的网络设备，它可以为接入交换机的任意两个网络节点提供独享的电信号通路。工作在数据链路层相当于多端口的网桥，允许端口之间建立多个并发连接，实现多个节点之间并发传输，每个端口所占带宽不会因为端口数量增加而减少
路由器：使用物理层或数据链路层的中继系统时只是把一个网络扩大了，而从网络层的角度看，它仍然是通一个网络，一般并不称之为网络互连，网络互联通常是指用路由器进行网络互联和路由选择。

### 2、常见应用层协议

（HTTP、DNS、FTP、DHCP、SMTP、POP3）

## 第六章 项目相关

1、系统问题排查：CPU、内存、网络、数据库瓶颈
2、超卖问题解决思路
3、实现分布式锁
4、大型分布式系统架构设计和调优。分布式系统架构设计：<https://zhuanlan.zhihu.com/p/159745617>
5、分布式架构的基本理论：CAP，BASE
6、设计模式
7、Nginx及负载均衡
8、设计一个秒杀系统。链接：<https://zhuanlan.zhihu.com/p/558395137>
9、成员查询问题 ，Bloom Filter
10、Top k频繁项
11、消息队列；

### 1、分布式架构下的高可用设计要点

（1）避免单点故障
l 负载均衡技术（failover、选址、硬件负载、软件负载、去中心化负载（gossip（redis-cluster））
l 热备Linux HA
l 多机房（同城灾备，异地灾备）
（2）应用高可用
l 故障监控（系统监控（CPU、内存）、链路监控、日志监控）自动预警
l 应用的容错设计（服务降级，限流）自我保护能力
l 数据量（数据分片，读写分离）
（3）分布式架构下的可伸缩设计
l 垂直伸缩，提升硬件能力
l 水平伸缩，增加服务节点（服务器）
l 加速静态内容（图片，脚本，静态页面等）访问速度的CDN（Content Delivery Network，内容分发网络）
2、秒杀系统设计要点
3、Web性能优化
1、DNS查询优化
2、客户端缓存
3、优化TCP连接
4、避免重定向
5、网络边缘的缓存
6、条件缓存
7、压缩和代码极简化
8、图片优化

## 第七章 数据结构及算法

可视化：<https://visualgo.net/en>

## 第八章 信息安全

1、在AES、Base64、DES、SHA-1、RSA、RC2、MD5、3DES、EdDSA中，
2、浏览器如何验证SSL证书是否有效？请简述流程
3、SQL注入实例
四、数据库基础
五、网站架构
如何解决并发导致的超卖问题
六、编程题
1、二分查找
2、18阶楼梯，1步2步走，共有多少种走法

## 第九章 技术储备

数字签名

### 计算机视觉

计算机视觉
1、计算机视觉（Computer Vision）为什么是它它有什么作用？基于什么原理和技术难题解决办法2、开源项目2.1、场景文本检测2.2、人体姿势估计2.3、自动驾驶车辆道路车道检测2.4、使用GAN进行自然风格转换2.5、人脸识别2.6、图像分类尾注
备注：计算机只能是辅助、包括人工智能也只能辅助，不能完全替代人，自动驾驶也一样，永远不可能完全依靠机器去做所有决定，只能帮助辅助驾驶，只能在某些方面尽量模仿人类，而永远达不到人类的情感和物品识别；
计算机视觉（Computer Vision）是人工智能领域的一个重要分支。它的目的是：看懂图像里的内容。
为什么是它
人的大脑皮层， 有差不多 70% 都是在处理视觉信息。 是人类获取信息最主要的渠道，没有之一。
在网络世界，照片和视频（图像的集合）也正在发生爆炸式的增长！
而在计算机视觉出现之前，图像对于计算机来说是黑盒的状态。一张图片对于机器只是一个文件。机器并不知道图片里的内容到底是什么，只知道这张图片是什么尺寸，多少MB，什么格式的。
而如果计算机、人工智能想要在现实世界发挥重要作用，就必须看懂图片！这就是计算机视觉要解决的问题。
它有什么作用？
1、图像分类：人脸识别、图片鉴黄、相册根据人物自动分类等。
2、目标检测：通过视频和图片，在图像中识别出特定目标，并标出其位置；
3、场景文字识别：停车场、收费站的车牌识别；
4、目标跟踪，人体关键点检测；
基于什么原理和技术
目前主流的基于深度学习的机器视觉方法，其原理跟人类大脑工作的原理比较相似。
人类的视觉原理如下：从原始信号摄入开始（瞳孔摄入像素 Pixels），接着做初步处理（大脑皮层某些细胞发现边缘和方向），然后抽象（大脑判定，眼前的物体的形状，是圆形的），然后进一步抽象（大脑进一步判定该物体是只气球）。
机器的方法也是类似：构造多层的神经网络，较低层的识别初级的图像特征，若干底层特征组成更上一层特征，最终通过多个层级的组合，最终在顶层做出分类。
难题
1、图像特征难以提取
对机器而来，特征难以提取（人能够轻易认识一个猫和狗。但是对机器而言即使是同一只猫在不同的角度，不同的光线，不同的动作下。像素差异是非常大的。就算是同一张照片，旋转90度后，其像素差异也非常大！）
2、需要计算的数据量巨大
手机上随便拍一张照片就是1000*2000像素的。每个像素 RGB 3个参数，一共有1000 X 2000 X 3=6,000,000。随便一张照片就要处理 600万 个参数，再算算现在越来越流行的 4K 视频。就知道这个计算量级有多恐怖了。
解决办法
CNN 解决了上面的两大难题
CNN 属于深度学习的范畴，它很好的解决了上面所说的2大难点：
CNN 可以有效的提取图像里的特征
CNN 可以将海量的数据（不影响特征提取的前提下）进行有效的降维，大大减少了对算力的要求
CNN 的具体原理这里不做具体说明，感兴趣的可以看看《一文看懂卷积神经网络-CNN（基本原理+独特价值+实际应用）》
2、开源项目
2.1、场景文本检测
在任何给定的场景中检测给定的场景是另外的一个非常有趣的问题。 场景文字就是出现在户外拍摄的图像中出现的字符。 例如， 道路上的车牌号， 道路上的公告牌等等。
场景图像中的文字在形状， 字体， 颜色和位置上都是变化的。由于光照和聚焦的不均匀性，使得场景文本识别的复杂度进一步增加。
下边这些流行的数据集将会丰富你分析场景文字检测的技能：
SVHN
街景门牌号码（SVHN）数据集是其中最受欢迎的开源数据集之一。它已用于Google创建的神经网络中，以读取门牌号并将其与地理位置匹配。这是一个很好的基准数据集，可用于练习， 学习和训练可准确识别街道编号的模型。此数据集包含从Google街景视图中获取的超过60万张带标签的真实房门图像。
SceneText数据集
场景文本数据集包含在不同环境中捕获的3000张图像，包括在不同光照条件下的室外和室内场景。图像是通过使用高分辨率数码相机或低分辨率移动电话相机捕获的。此外，所有图像均已调整为640×480。
此外，场景文本检测是一个两步过程，包括图像中的文本检测和文本识别。对于文本检测，我发现了最先进的深度学习方法EAST（高效准确场景文本检测器）。它可以找到水平和旋转边界框。您可以将其与任何文本识别方法结合使用。
这是有关场景文本检测的其他一些有趣的论文：
使用链接主义文本提议网络检测自然图像中的文本
COCO-Text：用于自然图像中文本检测和识别的数据集和基准
2.2、人体姿势估计
人体姿势估计是计算机视觉的有趣应用。您一定已经听说过Posenet，它是用于人体姿势估计的开源模型。简而言之，姿势估计是一种计算机视觉技术，可以推断图像/视频中存在的人或物体的姿势。
在讨论姿势估计的工作之前，让我们首先了解“人体姿势骨架”。它是定义一个人的姿势的一组坐标。一对坐标是肢体。此外，通过识别，定位和跟踪图像或视频中人类姿势骨架的关键点来执行姿势估计。
资源
如果要开发姿势估计模型，以下是一些数据集：
MPII
MPII Human Pose数据集是评估关节式姿势估计的最新基准。该数据集包含约25K图像，其中包含超过4 万名带注释的人体关节的人。总体而言，数据集涵盖410种人类活动，每个图像都有一个活动标签。
<http://human-pose.mpi-inf.mpg.de/HUMANEVA>
HumanEva-I数据集包含与3D人体姿势同步的7个校准视频序列。该数据库包含执行6个常见动作（例如，步行，慢跑，打手势等）的4个主题，这些动作被分为训练，验证和测试集。
我发现Google的DeepPose是一篇使用深度学习模型进行姿势估计非常有趣的研究论文。此外，您可以访问有关姿势估计的多个研究论文，以更好地理解它。
2.3、自动驾驶车辆道路车道检测
一个自主轿车是能够感知周围环境，并无需人类干预就能操作的交通工具。他们根据适合车辆不同部分的各种传感器创建并维护周围环境的地图。
这些车辆具有监视附近车辆位置的雷达传感器。摄像机检测交通信号灯，读取路标，跟踪其他车辆以及激光雷达（光检测和测距）传感器从汽车周围反射光脉冲以测量距离，检测道路边缘并识别车道标记
车道检测是这些车辆的重要组成部分。在公路运输中，车道是行车道的一部分，被指定用于单行车辆来控制和引导驾驶员并减少交通冲突。
在您的数据科学家的简历中添加一个令人兴奋的项目。以下是一些可用于实验的数据集-
TUsimple
该数据集是Tusimple车道检测挑战赛的一部分。它包含3626个视频片段，每个片段1秒。这些视频剪辑中的每一个都包含20帧，并带有带注释的最后一帧。它包含训练和测试数据集，其中包含3626个视频片段，训练数据集中的3626个带注释的帧和2782个用于测试的视频片段。
如果您正在寻找一些开发项目的教程，请查看下面的文章-
<https://github.com/TuSimple/tusimple-benchmark/issues/3.使用OpenCV>进行实时车道检测的动手教程（无人驾驶汽车项目！）
2.4、使用GAN进行自然风格转换
自然风格转换是一种使用一张图像的风格重建另一张图像的内容的计算机视觉技术。这是生成对抗网络（GAN）的应用， 这儿，我们输入了两张图像， 一张内容图像，另一张时风格参考图像， 然后将二者混合在一起以至于输出图像看起来像使用风格参考图像绘制出来的油画。
这是通过优化输出图像与内容图像匹配的内容统计和样式参考图像的样式统计来实现的。
资源
下边是一些用来练习非常令人惊叹的数据集：
COCO数据集
COCO是一个大规模的对象检测、分割和标注的数据集。数据集中的图像是从日常场景中捕获的日常对象。此外，它提供了多对象标记、分割掩码标注、图像标注和关键点检测，共有81个类别，使其成为一个非常通用和多用途的数据集。
ImageNet
上边已经提到过 一 ImageNet非常灵活多用。
如果你还不知道如何应用风格转换模型，这儿是一个tensorflow的教程可以帮助你， 而且， 如果你像更加升入了解这个技术我建议你阅读接下来的论文。
艺术风格的学术表达
使用循环一致对抗网络的无需配对的图像到图像的转换
使用卷积神经网络进行图像分割转换
2.5、人脸识别
人脸识别是计算机视觉最广泛的应用。人脸识别被应用在安全， 监控或者解锁手机。 这是一个在预先存在的数据集中在图像或者视频中确认你的人脸。 我们可以使用深度学习的方法来学习这些人脸的特征并且识别他们。
这是一个多个步骤的过程，这个过程由以下的步骤构成：
人脸检测： 这用来定位一个或者多个在图像或者视频中的人脸
人脸对齐： 对齐是用来规范化人脸在集合上与数据集一致
特征提取： 后来，提取特征并且用在识别任务中。
特征识别： 与数据库中的特征相匹配
下面的开放源数据集将为您提供良好的人脸识别机会：
MegaFace
MegaFace是一个大规模的公共人脸识别训练数据集，它是商业人脸识别问题最重要的基准之一。它包括4753320个人脸，672057个身份
Labeled faces in wild home
Labeled faces in wild home（LFW）是一个人脸照片数据库，旨在研究无约束人脸识别问题。它有13233张5749人的图片，是从网上发现和收集的。另外，1680名照片中的人在数据集中有两张或两张以上不同的照片。
此外， 为了更好的利用这些项目， 你可以使用像FaceNet这样的预训练模型。
Facenet是一种深度学习模型，它为人脸识别、验证和聚类任务提供了统一的嵌入。网络将每个人脸都映射在一个欧几里德网络中，每个图像之间的距离是相似的。
资源
也可以使用keras或者pytorch的预训练模型来构建自己的人脸识别系统。
还有一些更先进的人脸识别模型可供使用。Deepface是由Facebook的研究人员开发的基于CNN的Deep网络。这是在人脸识别任务中使用深度学习的一个重要里程碑。
为了更好地了解近30年来人脸识别技术的发展，我建议您阅读一篇有趣的论文，题目是：
Deep Face Recognition： A Survey
2.6、图像分类
图像分类是计算机视觉领域的基础任务， 目标是通过给每张图片分配一个标签来区分图像。对人类来说理解区分我们看到的图像很容易。 单是对于机器来说时非常不同的。 对于机器来说区分大象和汽车都是一件繁重的任务。
下边是几个最突出的图像分类开源项目：
Cifar10
CIFAR-10是一个在训练机器学习和计算机视觉算法常用的数据集，它是机器学习最受欢迎的数据集。 包含了60000张图像， 分为10类， 每张图像的的尺寸为32x32。 类别有飞机、汽车、鸟、猫、鹿、狗、青蛙、马、船和卡车。
<https://www.cs.toronto.edu/~kriz/cifar.htmlImageNet>
ImageNet数据集是一个为计算机视觉研究的巨大图像数据集， 这个数据集中有多于140万张图像被手供标注， 并且这些标注说明了图像中含有那些物体。并且有多余1万张图像标注了物品的边界框。 ImageNet包含了多余20000类的物品。
作为初学者，你可以使用keras或者pytorch从头开始学习神经网络， 为了能够得到更好的效果提升学习的层次， 我建议使用迁移学习预训练模型，例如CGG-16， Resnet-50，GoogleNet等等。
<http://image-net.org/downloadtop4的图像分类的python>代码
建议通读下边的文章更好的理解图像分类：
使用深度神经网络进行ImageNet的图像分类
卷积层数加深（VGG）
图像识别的深度残差网络（ResNet）
机器学习和人工智能
机器学习和人工智能（Machine Learning and Artificial Intelligence）
机器学习是人工智能的一个分支。
人工智能的研究历史有着一条从以“推理”为重点，到以“知识”为重点，再到以“学习”为重点的自然、清晰的脉络。
机器学习是实现人工智能的一个途径，即以机器学习为手段解决人工智能中的问题。

- 机器学习：
- 人工智能：
- 数据处理和分析展示computer
自动化和数据分析处理：兴趣和实际需求为主导，技术储备；
机器学习和人工智能：投入大，收获小，日常生活不实用、也不是个人发展方向；
TensorFlow 是一个开源的、基于 Python 的机器学习框架，它由 Google 开发，并在图形分类、音频处理、推荐系统和自然语言处理等场景下有着丰富的应用，是目前最热门的机器学习框架。
区块链、元宇宙、NFT
以太坊（Ethereum）是一个去中心化的，运行智能合约的区块链平台。
NFT是元宇宙的确权革命。
NFT是区块链技术的一种应用，NFT是发行在区块链上的差异性数字资产。区块链使数字资产的交易变得更加自由、可信和可靠。
数字化和虚拟化，一定是人类的大势所趋。区块链技术已被普遍认为是下一代互联网技术的核心，区块链为元宇宙的经济系统提供保障，加快元宇宙世界的构建，实现现实世界与虚拟世界的经济互通。而基于区块链的NFT，是通往元宇宙的必经之路，可以在元宇宙中帮助虚拟数字经济的确权，确定元宇宙世界中的社会稳定。
2022年10月18日 10:02:16
X86

## Go内存管理

吃饭唱歌法国说股有高一u说 用户登录 -> tokentoken ->用户基础信息token ->用户权限Gin自带参数解析, 采用ShouldBind做统一状态码响应，避免使用Bing400请求响应
2022年10月19日星期三
初级程序员 vs 高级程序员
从工作内容的角度出发，两者最大的区别，其实在于更关注的是“软件”还是“系统”。
初级程序员关心编写软件。因此，会重视代码质量，采用最佳实践，尝试采用尖端技术。他们在学习新技术方面投入了大量时间。对初级程序员来说，最终的目标是创建优雅的、可执行的、可维护的软件。
高级程序员关心构建系统。编写软件只是构建系统中的一个步骤。首先，他们需要对“一个软件是否需要创建”的问题做出思考，例如它会解决什么问题、为什么解决。并且，他们还会询问谁将使用该软件以及以何种规模使用该软件。同时，他们还需考虑软件将在哪里运行，以及如何监控它是否正常工作，软件是否真正解决了问题等。
高级程序员的不一样经历
事实上，构建系统比编写软件更复杂且困难，但也能带来更多的不一样的经历。
作为最了解软件的人，高级程序员懂得如何运行它、监视它、扩展它，更重要的是，他们的分析思维和解决问题的能力，对产品要求的见解非常有价值。
在构建系统的过程中，高级程序员需要参与以下的工作内容（非详尽）：
明确需求 。在与产品经理合作时，能够了解他们的问题并高效解决；
明确非功能性需求。需要与项目经理讨论系统应处理多少用户，对性能、吞吐量、延迟的要求，以及任何安全性或合规性注意事项等；
规划迭代。在团队合作中提出实施计划，确保某个期限内可是实现的目标；
确定依赖关系。在识别了团队外部的依赖关系后，直接与EM或团队合作，为他们获取一些ETA，随之相应地调整团队的目标；
测试。根据公司运营方式，需要与自身团队或QE团队一起决定测试策略。就推出所需的质量阈值达成一致（例如，没有未解决的主要错误或测试覆盖率超过 X%）；
部署。与团队合作，决定如何部署系统。例如是否需要一些新的基础架构、是否可以重用现有的基础架构、成本预算等；
可观察性。需要决定如何监控系统的运行状况，并设置解决生产问题的流程。同时，使用第三方解决方案（如相扑逻辑）为此目的设置监视器和仪表板；
推出沟通。在与团队和 PM 就推出日期达成一致时，需要确保所有利益相关者了解，并检查是否需要更改文档；
衡量成功。确定自身知晓项目是否成功的指标，例如是否有人使用新系、用户是否完成任务等，高级程序员可以利用可观察性套件来实现。

## 软件设计八大概念

抽象、体系结构、设计模式、模块化、信息隐藏、功能独立、精化、重构
抽象：
数据抽象：描述数据对象的冠名数据集合（门：包含属性：门的类型、转动方向、开门机关、重量和尺寸等）；
过程抽象；具有明确和有限功能的指令序列（开：一系列的过程：走到门前，伸出手并抓住把手，转动把手并拉开门，离开打开的门等）；
设计模式：在给定上下文环境中一类共同问题的共同解决方案。
模块化：软件被划分为命名和功能相对独立的多个组件（通常称为模块），通过这些组件的集成来满足问题的需求；
精化：逐步求精的过程。
重构：不改变组件功能和行为条件下，简化组件设计（或代码）的一种重组技术。
面向对象程序设计
1、含义：是以建立模型体现出来的抽象思维过程和面向对象的方法。
2、主要概念：对象、类、数据抽象、继承、动态绑定、数据封装、多态性、消息传递。
3、方法：选择程序设计语言、类的实现、方法的实现、用户接口的实现等。
4、语言：C++、JAVA、VB、VC++、C#
对象：万物皆对象，它包括现实中客观存在的事物，也包括抽象的时间、规则、思维。（对象具有状态、行为和标识）
类：具有相同特性和行为的对象组成的集合就是类，JAVA实际中的类就是指一个数据类型。
类是对象的抽象，而对象是类的具体实例。
类与对象的关系：抽象（该抽象是名词）与类的实例化就是对象，对象的共性特征抽象（该抽象是动词）出来就是类。
对象就是给实体，这个实体承载了类
Go借助结构体来实现类的声明,
面向对象的三个基本特征：封装、继承、多态
1.封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏；
2.面向对象编程（OOP）语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。（要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现）
3.多态：允许将子类型的指针赋值给父类类型指针，实现多态有两种方式，覆盖，重载。
封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。

## 生命科学和生物技术

国家发展改委｜“十四五”生物经济发展规划
规划背景：
（一）发展生物经济的重大意义
是顺应全球生物技术加速演进趋势、实现高水平科技自立自强的重要方向
是前瞻布局培育壮大生物产业、推动经济高质量发展的重要举措
是满足生命健康需求快速增长、满足人民对美好生活向往的重要内容
是加强国家生物安全风险防控、推进国家治理体系和治理能力现代化的重要保障
（二）发展形势
当前，生命科学已成为前沿科学研究活跃领域，生物技术成为促进未来发展的有效力量，生物经济正在勾勒人类社会未来发展的美好蓝图。
党的十八大以来，我国生物经济发展取得巨大成就，产业规模持续快速增长，门类齐全、功能完备的产业体系初步形成，生物领域创新能力大幅提升，生物安全建设取得历史性成就，生物安全政策体系不断完善。"十四五"时期，是生物技术加速演进、生命健康需求快速增长、生物产业迅猛发展的重要机遇期，我国生物经济发展前景广阔。
我国生物经济发展也面临不少挑战，全球疫情仍在持续演变，传统生物安全问题和新型生物安全风险相互叠加，生物产业原创能力仍较为薄弱，生物资源保护开发利用体系尚不完备，生物经济发展缺乏顶层设计和统筹协调等。
