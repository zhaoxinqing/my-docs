#

## Golang 基础

- `make` 和 `new` 的区别
- 数组和切片的区别
- `for range` 的时候它的地址变化
- 多个 `defer` 的执行顺序，`defer` 在什么时机会修改返回值？
- `uint` 类型溢出
- 介绍 `rune` 类型
- 解析 `tag` 是怎么实现的？反射原理是什么？
- 调用函数传入结构体时，应该传值还是指针？ （`Golang` 都是传值）`context` 结构，使用场景和用途
- `channel` 底层实现原理，是否线程安全，关闭问题？锁用在什么地方？
- `map` 主要特性，使用注意的点，删除一个 `key` 时的内存释放
- `Goroutine` 的并发编程模型基于的GMP模型
- 进程、线程、协程
- `Go` 如何实现原子操作？
- `Mutex` 是悲观锁还是乐观锁
- 并发控制
- `go gc` 是怎么实现的
- 如何优雅地实现一个 `goroutine` 池
- 内存相关：内存泄漏及内存泄漏的排查，内存逃逸，内存分配
- 介绍一下大对象小对象，为什么小对象多了会造成 `gc` 压力？通常小对象过多会导致 `GC` 三色法消耗过多的 `GPU`。优化思路是，减少对象分配。
- `go` 内存管理金字塔结构

## 特点

- 静态类型的编译型语言
- 具有很强的表达能力，它简洁、清晰而高效
- Go代码编译成机器码不仅非常迅速，还具有方便的垃圾收集机制和强大的运行时反射机制
- 益于其并发机制，用它编写的程序能够非常有效地利用多核与联网的计算机
- 其新颖的类型系统则使程序结构变得灵活而模块化
- 作为编程语言的后生，站在巨人的肩膀上，吸收了其他一些编程语言的特点

语言特点：<http://c.biancheng.net/view/3990.html>
详解链接：<https://juejin.cn/post/6844903808753991694>

## package

- 一个程序是由一个或多个可导入的包组成，每个包包含一个或多个文件
- 包的循环导入是不允许的，即如果fmt包导入了io包，那么io包就不能导入fmt包，也不能导入任何其他导入fmt的包，即使是间接的导入
- 首字母为大写字母的名字，如Printf和Writer，是'导出的'（公共的），其它的则不是

## 类型（Types）

- 布尔（bool）
- 定长整形，如uint8和int32
- 非定长整形int和uint（32位或64位，取决于机器大小）
- 定长浮点类型（float32和float64）
- 复数类型（complex64和complex128）
- 类似于c语言那样提供了指针、固定大小的数组和结构体类型
- 内置的字符串类型（string）
- 一个被称为map类型的哈希表
- 称为slice类型的动态大小的数组
- Go通过其接口类型提供面向对象的多态性
- Go没有提供类（class），但允许将方法（method）绑定到任何类型上，包括结构体、数组、切片、map，甚至是基本类型，如整数。它没有类型层次体系；继承往往会使程序在演化过程中更难适应。相反，go鼓励类型的组合。

## 并发（Concurrency）

- goroutines在一个共享地址空间中运行，并能被有效地通过多路复用机制调度到操作系统线程上。

## Select可以用于什么

常用于gorotine的完美退出。
golang 的 select 就是监听 IO 操作，当 IO 操作发生时，触发相应的动作每个case语句里必须是一个IO操作，确切的说，应该是一个面向channel的IO操作。
说说go语言的select机制
1.select 机制用来处理异步 IO 问题
2.select 机制最大的一条限制就是每个 case 语句里必须是一个 IO 操作
3.golang 在语言级别支持 select 关键字

Golang中select详解
select可以用于什么，常用于gorotine的完美退出。golang的select就是监听IO操作，当IO操作发生时，触发相应的动作。每个case语句里必须是一个IO操作，确切的说，应该是一个面向channel的IO操作。
链接：<https://wenku.baidu.com/view/cd79075401768e9951e79b89680203d8ce2f6aca.html>

## 闭包

- 作用：避免全局变量的滥用
- 指有权访问另一个函数作用域中的变量的函数
- 创建闭包的常见方式就是在一个函数内部创建另一个函数，内函数可以访问外函数的变量
- 注意：闭包里作用域返回的局部变量不会被立刻销毁回收，但过度使用闭包可能会占用更多内存，导致性能下降。

闭包的用法：<https://blog.csdn.net/qq_42696078/article/details/122006956>

## 标准库

- 常用标准库：<https://www.topgoer.com/常用标准库/>
- 标准库：<https://studygolang.com/pkgdoc>

Goer：<https://www.topgoer.com/>

GoLang之Context包的用途是什么
Context包，专门用来简化对于处理单个请求的多个goroutine之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个API调用。
详解：<https://blog.csdn.net/weixin_52690231/article/details/124694709>

## 内核

Golang的协程调度器原理及GMP设计思想
大量的进程/线程出现了新的问题

- 高内存占用；
- 调度的高消耗CPU；

调度器的设计策略
复用线程：避免频繁的创建、销毁线程，而是对线程的复用。
work stealing机制：当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。
hand off机制：当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。

M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。
P的数量：由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。
详解链接：<https://www.jianshu.com/p/c68100dc60e0>

## 内存管理

1、内存分配：
Golang中也实现了内存分配器，原理与tcmalloc类似，简单的说就是维护一块大的全局内存，每个线程(Golang中为P)维护一块小的私有内存，私有内存不足再从全局申请。
预申请的内存划分为spans、bitmap、arena三部分：
arena即为所谓的堆区，大小为512G，应用中需要的内存从这里分配，为了方便管理把arena区域划分成一个个的page，每个page为8KB,一共有512GB/8KB个页；
spans区域存放span的指针，每个指针对应一个page，所以span区域的大小为(512GB/8KB)*指针大小8byte =512M；span是内存管理的基本单位，next和prev用于将多个span链接起来，有利于管理多个span；
bitmap区域大小也是通过arena计算出来，不过主要用于GC；

为了避免多线程申请内存时不断的加锁，Golang为每个线程分配了span的缓存，这个缓存即是cache；
cache作为线程的私有资源为单个线程服务，而central则是全局资源，为多个线程服务，当某个线程内存不足时会向central申请，当某个线程释放内存时又会回收进central。
每个mcentral对象只管理特定的class规格的span。事实上每种class都会对应一个mcentral,这个mcentral的集合存放于mheap数据结构中，mheap管理着全部的内存，事实上Golang就是通过一个mheap类型的全局变量进行内存管理的。

2、垃圾回收：
常见的垃圾清理算法有：引用计数、标记清除、分代收集；
golang采用三色标记法：
灰色：对象还在标记队列中等待
黑色：对象已被标记，gcmarkBits对应的位为1（该对象不会在本次GC中被清理）
白色：对象未被标记，gcmarkBits对应的位为0（该对象将会在本次GC中被清理）
Stop The World：对于垃圾回收来说，回收过程中也需要控制住内存的变化，否则回收过程中指针传递会引起内存引用关系变化，如果错误的回收了还在使用的内存，结果将是灾难性的。Golang中的STW（Stop The World）就是停掉所有的goroutine，专心做垃圾回收，待垃圾回收结束后再恢复goroutine。STW时间的长短直接影响了应用的执行，时间过长对于一些web应用来说是不可接受的，这也是广受诟病的原因之一。为了缩短STW的时间，Golang不断优化垃圾回收算法（写屏障，），这种情况得到了很大的改善。
垃圾回收触发时机：内存分配量达到阀值，定期触发GC，手动触发
3、逃逸分析
如果分配在栈中，则函数执行结束可自动将内存回收；
如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理;

1. 如果函数外部没有引用，则优先放到栈中；
2. 如果函数外部存在引用，则必定放到堆中；
指针逃逸（Go可以返回局部变量指针，这其实是一个典型的变量逃逸案例）；
栈空间不足逃逸，当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中；
动态类型逃逸：很多函数参数为interface类型，比如fmt.Println(a …interface{})，编译期间很难确定其参数的具体类型，也人产生逃逸。
闭包引用对象逃逸
传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。

## 线程安全

线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。

GoLang之变量是分配在栈（stack）上还是堆（heap）上？
准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。然而，如果编译器不能确保变量在函数 return 之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上,然而，还要对这些变量做逃逸分析，如果函数 return 之后，变量不再被引用，则将其分配到栈上。
意思是说go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。go语言声称这样可以释放程序员关于内存的使用限制，更多的让程序员关注于程序功能逻辑本身。个人觉得这是扯淡，属于自作主张的小聪明，非常不喜欢这个设计。还是C/C++的逻辑非常清楚：简单逻辑是，声明的局部变量分配在栈，通过动态申请(malloc, new)的内存在堆里。

内存泄露的几种场景
1.大数组放在形参场景下，通常使用切片或者指针进行传递，避免短时间的内存使用激增。
2.定时器的使用（time.Ticker是每隔指定的时间就会向通道内写数据。作为循环触发器，必须调用stop方法才会停止，从而被GC掉，否则会一直占用内存空间）
3.如果Goroutine在执行时被阻塞而无法退出，就会导致Goroutine的内存泄漏，一个Goroutine的最低栈大小为2KB，在高并发的场景下，对内存的消耗也是非常恐怖的！（goroutine的安全退出）
(1)互斥锁未释放；
(2)死锁；
(3)空channel；
(4)能出不能进；
(5)能进不能出；
可以通过 context包 来避免内存（goroutine）泄漏（）

Golang的内存模型，为什么小对象多了会造成gc压力
通常小对象过多会导致 GC 三色法消耗过多的GPU。优化思路是，减少对象分配。

## Golang数据类型

数组、切片、赋值：
1.Go 中数组赋值和函数传参都是值复制的，大数组传递给函数会消耗很多内存，采用切片的方式传参可以避免上述问题。切片是引用传递，所以它们不需要使用额外的内存并且比使用数组更有效率；
2.切片本身是一个只读对象，其工作机制类似数组指针的一种封装。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内；
3.切片的结构体由3部分构成，Pointer 是指向一个数组的指针，len 代表当前切片的长度，cap 是当前切片的容量。cap 总是大于等于 len 的；
4.Go 中切片扩容的策略：如果切片的容量小于 1024 个元素，扩容的时候就翻倍增加容量。一旦元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，即每次增加原来容量的四分之一。
5.如果用 range 的方式去遍历一个切片，拿到的 Value 其实是切片里面的值拷贝。所以每次打印 Value 的地址都不变。由于 Value 是值拷贝的，并非引用传递，所以直接改 Value 是达不到更改原切片值的目的的，需要通过 &slice[index] 获取真实的地址。
6.Golang 内置的 copy() 函数可以将一个切片中的元素拷贝到另一个切片中，返回值为拷贝成功的元素个数。如果 src 比 dst 长，就截断；如果 src 比 dst 短，则只拷贝 src 那部分；
7.slice在扩容的过程中，会重新创建底层数组，data指向新的数组；如果slice触发扩容，data会指向新的底层数组，⽽不指向外部的底层数组了。所以之后再修改slice，不会对外部的slice造成影响；
Golang切片和数组底层详解：<https://blog.csdn.net/skh2015java/article/details/79771799>

Channel：
一般用于协程之间的通信，也可以用于并发控制。一个channel只能传递一种类型的值，一个channel同时仅允许被一个goroutine读写；select可以监控多channel，比如监控多个channel，当其中某一个channel有数据时，就从其读出数据。
Channel无缓冲的或者有缓冲的已满，如果不接收数据，会阻塞；
详解：<https://my.oschina.net/u/157514/blog/149192>
Map：
使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，也即bucket，而每个bucket就保存了map中的一个或一组键值对。当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用链地址法来解决键冲突。由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来；

map如何顺序读取
map不能顺序读取，是因为他是无序的，想要有序读取，首先的解决的问题就是，把key变为有序，所以可以把key放入切片，对切片进行排序，遍历切片，通过key取值。

指针：
指针就是变量，用来存放地址的变量（存放在指针中的值都当成地址处理），但是指针的字节长度是固定的。因为指针保存的是地址，由操作系统的位数决定，32位机的字节是4，64位机的字节是8。

## 引用传递和值传递

所谓值传递，就是实参通过拷贝将⾃⾝内容传递给形参实参通过拷贝将⾃⾝内容传递给形参。也就是将传递的内容拷贝⼀份，给函数；
Slice在扩容过程中，会重新创建底层数组，data指向新的数组。
总结：
1.go中函数传递都是值传递；
2.slice、map、channel都是引⽤类型，即便是值传递，结构内部还是指向原来的引⽤对象，所以函数体内可以直接修改元素；

值类型、引用类型：<https://www.jb51.net/article/182727.htm>

## 空struct{}的用途

空结构体 struct{} 实例不占据任何的内存空间，可以使用 unsafe.Sizeof 计算出一个数据类型实例需要占用的字节数；
golang 空结构体 struct{} 可以用来节省内存；
将 map 作为集合(Set)使用时，可以将值类型定义为空结构体，仅作为占位符使用即可；
不发送数据的信道(channel)。使用 channel 不需要发送任何的数据，只用来通知子协程(goroutine)执行任务，或只用来控制协程并发度。
结构体只包含方法，不包含任何的字段

链接：<https://blog.csdn.net/weixin_44328662/article/details/86501900>

实现Set类型的数据结构（code）
对于Set类型的数据结构，其实本质上跟List没什么多大的区别。无非是Set不能含有重复的Item的特性，Set有初始化、Add、Clear、Remove、Contains等操作。
详解：<https://www.jb51.net/article/170043.htm>

其它：
go语言触发异常（panic）的场景有哪些
空指针解析
下标越界
除数为0
调用 panic 函数
channel已经被关闭，再次关闭会产生panic，这时通过recover使程序恢复正常。（使用sync.Once或互斥锁sync.Mutex确保channel只被关闭一次。）

## 知识点汇总

链接：<https://www.topgoer.cn/docs/gomianshiti/golangInterview>

## 语言规范-编码风格

<https://shockerli.net/post/go-code-guide-style/>
<https://learnku.com/go/wikis/38426>

1、使用Go实现消息队列（多生产者，多消费者）（code）
使用切片加锁可以实现
链接：<https://blog.csdn.net/CY2333333/article/details/124493409>

2、用golang实现一个定时器任务队列实例（code）
详解：<https://www.yisu.com/zixun/182743.html>

3、GOLANG实现crontab定时器功能
详解：<http://t.zoukankan.com/Yemilice-p-12540258.html>

开发中遇见的问题：
1.业务逻逻辑不清晰的，需求确定（金地审批业务流）；
2.算法和性能困难的（调整实现方法和逻辑，HTML-TO-PDF下载）；
3.新功能工具刚接触不熟练的，先找官网了解，帖子辅助了解，最后研究讨论（Nacos，Redis，PostGis）；
链接：<https://www.jianshu.com/p/e2ebfc4b80f1>

GO语言高性能编程
链接：<https://geektutu.com/post/hpg-exit-goroutine.html>

Golang中协程退出方式
链接：<https://blog.csdn.net/taw19960426/article/details/124380196>

语言特点：
Go语言，作为编程语言的后生，站在巨人的肩膀上，吸收了其他一些编程语言的特点。
Go编程语言是一个开源项目，它使程序员更具生产力。Go语言具有很强的表达能力，它简洁、清晰而高效。得益于其并发机制，用它编写的程序能够非常有效地利用多核与联网的计算机，其新颖的类型系统则使程序结构变得灵活而模块化。Go代码编译成机器码不仅非常迅速，还具有方便的垃圾收集机制和强大的运行时反射机制。它是一个快速的、静态类型的编译型语言，感觉却像动态类型的解释型语言。——Go语言官网
详解链接：<https://juejin.cn/post/6844903808753991694>

Select可以用于什么
常用于gorotine的完美退出。
golang 的 select 就是监听 IO 操作，当 IO 操作发生时，触发相应的动作每个case语句里必须是一个IO操作，确切的说，应该是一个面向channel的IO操作。
说说go语言的select机制
1.select 机制用来处理异步 IO 问题
2.select 机制最大的一条限制就是每个 case 语句里必须是一个 IO 操作
3.golang 在语言级别支持 select 关键字

Golang中select详解
select可以用于什么，常用语gorotine的完美退出。golang的select就是监听IO操作，当IO操作发生时，触发相应的动作。每个case语句里必须是一个IO操作，确切的说，应该是一个面向channel的IO操作。
链接：<https://wenku.baidu.com/view/cd79075401768e9951e79b89680203d8ce2f6aca.html>

什么是闭包
说到Go语言的闭包，不得不说说全局变量和局部变量
全局变量的特点：
常驻内存
污染全局
局部变量的特点：
不常驻内存
不污染全局
而Go语言的闭包可以做到：
1.可以让变量常驻内存
2.可以让变量不污染全局
所以闭包主要是为了避免全局变量的滥用。
闭包
闭包是指有权访问另一个函数作用域中的变量的函数
创建闭包的常见方式就是在一个函数内部创建另一个函数， 内函数可以访问外函数的变量
注意：闭包里作用域返回的局部变量不会被立刻销毁回收，但过度使用闭包可能会占用更多内存，导致性能下降。
闭包的用法：<https://blog.csdn.net/qq_42696078/article/details/122006956>

标准库：
<https://studygolang.com/pkgdoc>
常用标准库：<https://www.topgoer.com/常用标准库/>

Goer：<https://www.topgoer.com/>

Printf()、Sprintf()、Fprintf()函数的区别用法是什么
都是把格式好的字符串输出，只是输出的目标不一样。
Printf()，是把格式字符串输出到标准输出（一般是屏幕，可以重定向）。Printf() 是和标准输出文件 (stdout) 关联的，Fprintf 则没有这个限制。
Sprintf()，是把格式字符串输出到指定字符串中，所以参数比printf多一个char*。那就是目标字符串地址。

Fprintf()，是把格式字符串输出到指定文件设备中，所以参数比 printf 多一个文件指针 FILE*。主要用于文件操作。Fprintf() 是格式化输出到一个stream，通常是到文件。
详解：<https://blog.csdn.net/Sunshineoe/article/details/120401167>
GoLang之Context包的用途是什么
Context包，专门用来简化对于处理单个请求的多个goroutine之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个API调用。
详解：<https://blog.csdn.net/weixin_52690231/article/details/124694709>

内核：
Golang的协程调度器原理及GMP设计思想
大量的进程/线程出现了新的问题
高内存占用；
调度的高消耗CPU；

调度器的设计策略
复用线程：避免频繁的创建、销毁线程，而是对线程的复用。
work stealing机制：当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。
hand off机制：当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。

M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。
P的数量：由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。
详解链接：<https://www.jianshu.com/p/c68100dc60e0>

功能：
1、使用Go实现消息队列（多生产者，多消费者）（code）
使用切片加锁可以实现
链接：<https://blog.csdn.net/CY2333333/article/details/124493409>

2、用golang实现一个定时器任务队列实例（code）
详解：<https://www.yisu.com/zixun/182743.html>

3、GOLANG实现crontab定时器功能
详解：<http://t.zoukankan.com/Yemilice-p-12540258.html>

内存管理：
1、内存分配：
Golang中也实现了内存分配器，原理与tcmalloc类似，简单的说就是维护一块大的全局内存，每个线程(Golang中为P)维护一块小的私有内存，私有内存不足再从全局申请。
预申请的内存划分为spans、bitmap、arena三部分：
arena即为所谓的堆区，大小为512G，应用中需要的内存从这里分配，为了方便管理把arena区域划分成一个个的page，每个page为8KB,一共有512GB/8KB个页；
spans区域存放span的指针，每个指针对应一个page，所以span区域的大小为(512GB/8KB)*指针大小8byte =512M；span是内存管理的基本单位，next和prev用于将多个span链接起来，有利于管理多个span；
bitmap区域大小也是通过arena计算出来，不过主要用于GC；

为了避免多线程申请内存时不断的加锁，Golang为每个线程分配了span的缓存，这个缓存即是cache；
cache作为线程的私有资源为单个线程服务，而central则是全局资源，为多个线程服务，当某个线程内存不足时会向central申请，当某个线程释放内存时又会回收进central。
每个mcentral对象只管理特定的class规格的span。事实上每种class都会对应一个mcentral,这个mcentral的集合存放于mheap数据结构中，mheap管理着全部的内存，事实上Golang就是通过一个mheap类型的全局变量进行内存管理的。

2、垃圾回收：
常见的垃圾清理算法有：引用计数、标记清除、分代收集；
golang采用三色标记法：
灰色：对象还在标记队列中等待
黑色：对象已被标记，gcmarkBits对应的位为1（该对象不会在本次GC中被清理）
白色：对象未被标记，gcmarkBits对应的位为0（该对象将会在本次GC中被清理）
Stop The World：对于垃圾回收来说，回收过程中也需要控制住内存的变化，否则回收过程中指针传递会引起内存引用关系变化，如果错误的回收了还在使用的内存，结果将是灾难性的。Golang中的STW（Stop The World）就是停掉所有的goroutine，专心做垃圾回收，待垃圾回收结束后再恢复goroutine。STW时间的长短直接影响了应用的执行，时间过长对于一些web应用来说是不可接受的，这也是广受诟病的原因之一。为了缩短STW的时间，Golang不断优化垃圾回收算法（写屏障，），这种情况得到了很大的改善。
垃圾回收触发时机：内存分配量达到阀值，定期触发GC，手动触发
3、逃逸分析
如果分配在栈中，则函数执行结束可自动将内存回收；
如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理;

1. 如果函数外部没有引用，则优先放到栈中；
2. 如果函数外部存在引用，则必定放到堆中；
指针逃逸（Go可以返回局部变量指针，这其实是一个典型的变量逃逸案例）；
栈空间不足逃逸，当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中；
动态类型逃逸：很多函数参数为interface类型，比如fmt.Println(a …interface{})，编译期间很难确定其参数的具体类型，也人产生逃逸。
闭包引用对象逃逸
传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。

线程安全
线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。

GoLang之变量是分配在栈（stack）上还是堆（heap）上？
准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。然而，如果编译器不能确保变量在函数 return 之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上,然而，还要对这些变量做逃逸分析，如果函数 return 之后，变量不再被引用，则将其分配到栈上。
意思是说go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。go语言声称这样可以释放程序员关于内存的使用限制，更多的让程序员关注于程序功能逻辑本身。个人觉得这是扯淡，属于自作主张的小聪明，非常不喜欢这个设计。还是C/C++的逻辑非常清楚：简单逻辑是，声明的局部变量分配在栈，通过动态申请(malloc, new)的内存在堆里。

内存泄露的几种场景
1.大数组放在形参场景下，通常使用切片或者指针进行传递，避免短时间的内存使用激增。
2.定时器的使用（time.Ticker是每隔指定的时间就会向通道内写数据。作为循环触发器，必须调用stop方法才会停止，从而被GC掉，否则会一直占用内存空间）
3.如果Goroutine在执行时被阻塞而无法退出，就会导致Goroutine的内存泄漏，一个Goroutine的最低栈大小为2KB，在高并发的场景下，对内存的消耗也是非常恐怖的！（goroutine的安全退出）
(1)互斥锁未释放；
(2)死锁；
(3)空channel；
(4)能出不能进；
(5)能进不能出；
可以通过 context包 来避免内存（goroutine）泄漏（）

Golang的内存模型，为什么小对象多了会造成gc压力
通常小对象过多会导致 GC 三色法消耗过多的GPU。优化思路是，减少对象分配。

## 触发异常（panic）的场景

- 空指针解析
- 下标越界
- 除数为0
- 调用 panic 函数
- channel已经被关闭，再次关闭会产生panic，这时通过recover使程序恢复正常。（使用sync.Once或互斥锁sync.Mutex确保channel只被关闭一次。）

## 数据类型

Channel：一般用于协程之间的通信，也可以用于并发控制。一个channel只能传递一种类型的值，一个channel同时仅允许被一个goroutine读写；select可以监控多channel，比如监控多个channel，当其中某一个channel有数据时，就从其读出数据。
Channel无缓冲的或者有缓冲的已满，如果不接收数据，会阻塞；
详解：<https://my.oschina.net/u/157514/blog/149192>

Slice：
又称动态数组，依托数组实现，可以方便的进行扩容、传递等，实际使用中比数组更灵活；从数据结构看Slice很清晰，array指针指向底层数组，len表示切片长度，cap表示底层数组容量；使用make来创建Slice时，可以同时指定长度和容量，创建时底层会分配一个数组，数组的长度即容量；
Map：
使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，也即bucket，而每个bucket就保存了map中的一个或一组键值对。当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用链地址法来解决键冲突。由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来；

map如何顺序读取
map不能顺序读取，是因为他是无序的，想要有序读取，首先的解决的问题就是，把key变为有序，所以可以把key放入切片，对切片进行排序，遍历切片，通过key取值。

指针
指针就是变量，用来存放地址的变量（存放在指针中的值都当成地址处理），但是指针的字节长度是固定的。
因为指针保存的是地址，由操作系统的位数决定，32位机的字节是4，64位机的字节是8。

引用传递和值传递
slice在扩容的过程中，会重新创建底层数组，data指向新的数组
所谓值传递，就是实参通过拷贝将⾃⾝内容传递给形参实参通过拷贝将⾃⾝内容传递给形参。也就是将传递的内容拷贝⼀份，给函数；
Slice在扩容过程中，会重新创建底层数组，data指向新的数组。
总结：
1.Go中函数传递都是值传递go中函数传递都是值传递；
2.slice、map、channel都是引⽤类型，即便是值传递，结构内部还是指向原来的引⽤对象，所以函数体内可以直接修改元素；
3.如果slice触发扩容，data会指向新的底层数组，⽽不指向外部的底层数组了。所以之后再修改slice，不会对外部的slice造成影响；

值类型、引用类型
详解：<https://www.jb51.net/article/182727.htm>

空struct{}的用途
空结构体 struct{} 实例不占据任何的内存空间，可以使用 unsafe.Sizeof 计算出一个数据类型实例需要占用的字节数；
golang 空结构体 struct{} 可以用来节省内存；
将 map 作为集合(Set)使用时，可以将值类型定义为空结构体，仅作为占位符使用即可；
不发送数据的信道(channel)。使用 channel 不需要发送任何的数据，只用来通知子协程(goroutine)执行任务，或只用来控制协程并发度。
结构体只包含方法，不包含任何的字段

链接：<https://blog.csdn.net/weixin_44328662/article/details/86501900>

实现Set类型的数据结构（code）
对于Set类型的数据结构，其实本质上跟List没什么多大的区别。无非是Set不能含有重复的Item的特性，Set有初始化、Add、Clear、Remove、Contains等操作。
详解：<https://www.jb51.net/article/170043.htm>

其它：
Go题汇总：
链接：<https://www.topgoer.cn/docs/gomianshiti/golangInterview>

语言规范-编码风格：
<https://shockerli.net/post/go-code-guide-style/>
<https://learnku.com/go/wikis/38426>

开发中遇见的问题：
1.业务逻逻辑不清晰的，需求确定（金地审批业务流）；
2.算法和性能困难的（调整实现方法和逻辑，HTML-TO-PDF下载）；
3.新功能工具刚接触不熟练的，先找官网了解，帖子辅助了解，最后研究讨论（Nacos，Redis，PostGis）；
链接：<https://www.jianshu.com/p/e2ebfc4b80f1>

GO语言高性能编程
链接：<https://geektutu.com/post/hpg-exit-goroutine.html>

Golang中协程退出方式
链接：<https://blog.csdn.net/taw19960426/article/details/124380196>

## context

- 在Go 里，我们不能直接杀死协程，协程的关闭一般会用 channel+select 方式来控制。但是在某些场景下，例如处理一个请求衍生了很多协程，这些协程之间是相互关联的：需要共享一些全局变量、有共同的 deadline 等，而且可以同时被关闭。再用 channel+select 就会比较麻烦，这时就可以通过 context 来实现。简而言之，context 是用来解决 goroutine 之间退出通知、元数据传递的功能库。

- 并发控制和超时控制的标准做法
